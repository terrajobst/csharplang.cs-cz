---
ms.openlocfilehash: 61eeae6173eaa19f9cf6d6e985f3dc107d4c3ac9
ms.sourcegitcommit: 3fc033b6e98ed7ecdf46a85c79b00a3a3ddcf963
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/18/2019
ms.locfileid: "50245523"
---
# <a name="conversions"></a><span data-ttu-id="ba1b0-101">Převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-101">Conversions</span></span>

<span data-ttu-id="ba1b0-102">A ***převod*** umožňuje výraz, který se považují za určitého typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-102">A ***conversion*** enables an expression to be treated as being of a particular type.</span></span> <span data-ttu-id="ba1b0-103">Převod může způsobit, že výraz daného typu zacházeno jako s jiným typem, nebo může to způsobit bez typu, chcete-li získat typ výrazu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-103">A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type.</span></span> <span data-ttu-id="ba1b0-104">Může být převody ***implicitní*** nebo ***explicitní***, a určuje, jestli se vyžaduje explicitní přetypování.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-104">Conversions can be ***implicit*** or ***explicit***, and this determines whether an explicit cast is required.</span></span> <span data-ttu-id="ba1b0-105">Například převod z typu `int` na typ `long` je implicitní, takže výrazy typu `int` lze implicitně považovat za typ `long`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-105">For instance, the conversion from type `int` to type `long` is implicit, so expressions of type `int` can implicitly be treated as type `long`.</span></span> <span data-ttu-id="ba1b0-106">Opačné převod z typu `long` na typ `int`, je explicitní a proto se vyžaduje explicitní přetypování.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-106">The opposite conversion, from type `long` to type `int`, is explicit and so an explicit cast is required.</span></span>

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

<span data-ttu-id="ba1b0-107">Některé převody jsou definovány jazykem.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-107">Some conversions are defined by the language.</span></span> <span data-ttu-id="ba1b0-108">Programy můžou také definovat své vlastní převody ([uživatelem definované převody](conversions.md#user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-108">Programs may also define their own conversions ([User-defined conversions](conversions.md#user-defined-conversions)).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="ba1b0-109">Implicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-109">Implicit conversions</span></span>

<span data-ttu-id="ba1b0-110">Následující převody jsou klasifikovány jako implicitní převody:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-110">The following conversions are classified as implicit conversions:</span></span>

*  <span data-ttu-id="ba1b0-111">Převody identity</span><span class="sxs-lookup"><span data-stu-id="ba1b0-111">Identity conversions</span></span>
*  <span data-ttu-id="ba1b0-112">Implicitní číselné převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-112">Implicit numeric conversions</span></span>
*  <span data-ttu-id="ba1b0-113">Výčet implicitní převody.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-113">Implicit enumeration conversions.</span></span>
*  <span data-ttu-id="ba1b0-114">Implicitní převod s možnou hodnotou Null</span><span class="sxs-lookup"><span data-stu-id="ba1b0-114">Implicit nullable conversions</span></span>
*  <span data-ttu-id="ba1b0-115">Literál null převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-115">Null literal conversions</span></span>
*  <span data-ttu-id="ba1b0-116">Odkaz na implicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-116">Implicit reference conversions</span></span>
*  <span data-ttu-id="ba1b0-117">Zabalení převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-117">Boxing conversions</span></span>
*  <span data-ttu-id="ba1b0-118">Implicitní převody na dynamický</span><span class="sxs-lookup"><span data-stu-id="ba1b0-118">Implicit dynamic conversions</span></span>
*  <span data-ttu-id="ba1b0-119">Konstantní výraz implicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-119">Implicit constant expression conversions</span></span>
*  <span data-ttu-id="ba1b0-120">Uživatelem definované implicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-120">User-defined implicit conversions</span></span>
*  <span data-ttu-id="ba1b0-121">Převody anonymní funkce</span><span class="sxs-lookup"><span data-stu-id="ba1b0-121">Anonymous function conversions</span></span>
*  <span data-ttu-id="ba1b0-122">Převody skupiny – metoda</span><span class="sxs-lookup"><span data-stu-id="ba1b0-122">Method group conversions</span></span>

<span data-ttu-id="ba1b0-123">Implicitní převod může dojít v různých situacích, včetně volání členské funkce ([kompilace kontrolu dynamické přetížení](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), výrazy přetypování ([výrazy přetypování](expressions.md#cast-expressions)), a přiřazení ([operátory přiřazení](expressions.md#assignment-operators)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-123">Implicit conversions can occur in a variety of situations, including function member invocations ([Compile-time checking of dynamic overload resolution](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), and assignments ([Assignment operators](expressions.md#assignment-operators)).</span></span>

<span data-ttu-id="ba1b0-124">Předdefinované implicitních převodů proběhnout úspěšně a nikdy nezpůsobí výjimky, která je vyvolána.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-124">The pre-defined implicit conversions always succeed and never cause exceptions to be thrown.</span></span> <span data-ttu-id="ba1b0-125">Správně navržená uživatelem definované implicitní převody by měly vykazovat také tyto vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-125">Properly designed user-defined implicit conversions should exhibit these characteristics as well.</span></span>

<span data-ttu-id="ba1b0-126">Pro účely převod typy `object` a `dynamic` jsou považovány za ekvivalentní.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-126">For the purposes of conversion, the types `object` and `dynamic` are considered equivalent.</span></span>

<span data-ttu-id="ba1b0-127">Ale dynamické převody ([implicitních převodů dynamické](conversions.md#implicit-dynamic-conversions) a [explicitních převodů dynamické](conversions.md#explicit-dynamic-conversions)) se vztahují pouze na výrazy typu `dynamic` ([dynamického typu](types.md#the-dynamic-type)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-127">However, dynamic conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)) apply only to expressions of type `dynamic` ([The dynamic type](types.md#the-dynamic-type)).</span></span>

### <a name="identity-conversion"></a><span data-ttu-id="ba1b0-128">Převod identity</span><span class="sxs-lookup"><span data-stu-id="ba1b0-128">Identity conversion</span></span>

<span data-ttu-id="ba1b0-129">Konverzi identity převede na stejný typ z libovolného typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-129">An identity conversion converts from any type to the same type.</span></span> <span data-ttu-id="ba1b0-130">Tak, že entita, která už má požadovaný typ může být říká, že lze převést na daný typ existuje tento převod.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-130">This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</span></span>

*  <span data-ttu-id="ba1b0-131">Protože objektu a dynamicky se považují za ekvivalentní je konverzi identity mezi `object` a `dynamic`a mezi sestavené typy, které jsou stejné při nahrazení všech výskytů `dynamic` s `object`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-131">Because object and dynamic are considered equivalent there is an identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing all occurrences of `dynamic` with `object`.</span></span>

### <a name="implicit-numeric-conversions"></a><span data-ttu-id="ba1b0-132">Implicitní číselné převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-132">Implicit numeric conversions</span></span>

<span data-ttu-id="ba1b0-133">Implicitní číselné převody jsou:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-133">The implicit numeric conversions are:</span></span>

*  <span data-ttu-id="ba1b0-134">Z `sbyte` k `short`, `int`, `long`, `float`, `double`, nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-134">From `sbyte` to `short`, `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="ba1b0-135">Z `byte` k `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-135">From `byte` to `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="ba1b0-136">Z `short` k `int`, `long`, `float`, `double`, nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-136">From `short` to `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="ba1b0-137">Z `ushort` k `int`, `uint`, `long`, `ulong`, `float`, `double`, nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-137">From `ushort` to `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="ba1b0-138">Z `int` k `long`, `float`, `double`, nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-138">From `int` to `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="ba1b0-139">Z `uint` k `long`, `ulong`, `float`, `double`, nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-139">From `uint` to `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="ba1b0-140">Z `long` k `float`, `double`, nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-140">From `long` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="ba1b0-141">Z `ulong` k `float`, `double`, nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-141">From `ulong` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="ba1b0-142">Z `char` k `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-142">From `char` to `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="ba1b0-143">Z `float` k `double`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-143">From `float` to `double`.</span></span>

<span data-ttu-id="ba1b0-144">Převody z `int`, `uint`, `long`, nebo `ulong` k `float` a z `long` nebo `ulong` k `double` může způsobit ztrátu přesnosti, ale nikdy příčinou ke ztrátě velikosti.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-144">Conversions from `int`, `uint`, `long`, or `ulong` to `float` and from `long` or `ulong` to `double` may cause a loss of precision, but will never cause a loss of magnitude.</span></span> <span data-ttu-id="ba1b0-145">Jiných implicitních číselných převodů nikdy ztraceny žádné informace.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-145">The other implicit numeric conversions never lose any information.</span></span>

<span data-ttu-id="ba1b0-146">Neexistují žádné implicitní převody na `char` tak hodnoty celočíselných typů nejde automaticky převést na typ `char` typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-146">There are no implicit conversions to the `char` type, so values of the other integral types do not automatically convert to the `char` type.</span></span>

### <a name="implicit-enumeration-conversions"></a><span data-ttu-id="ba1b0-147">Výčet implicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-147">Implicit enumeration conversions</span></span>

<span data-ttu-id="ba1b0-148">Povoluje výčet implicitní převod *decimal_integer_literal* `0` má být převeden na jakýkoli *enum_type* a k libovolnému *nullable_type* jehož Základní typ je *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-148">An implicit enumeration conversion permits the *decimal_integer_literal* `0` to be converted to any *enum_type* and to any *nullable_type* whose underlying type is an *enum_type*.</span></span> <span data-ttu-id="ba1b0-149">V druhém případě je vyhodnocen převod převedením na základní *enum_type* a balení výsledek ([typy připouštějící hodnotu Null](types.md#nullable-types)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-149">In the latter case the conversion is evaluated by converting to the underlying *enum_type* and wrapping the result ([Nullable types](types.md#nullable-types)).</span></span>

### <a name="implicit-interpolated-string-conversions"></a><span data-ttu-id="ba1b0-150">Interpolované řetězce implicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-150">Implicit interpolated string conversions</span></span>

<span data-ttu-id="ba1b0-151">Implicitní interpolované řetězce převod povolení *interpolated_string_expression* ([interpolovaných řetězců](expressions.md#interpolated-strings)) má být převeden na `System.IFormattable` nebo `System.FormattableString` (která implementuje `System.IFormattable`).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-151">An implicit interpolated string conversion permits an *interpolated_string_expression* ([Interpolated strings](expressions.md#interpolated-strings)) to be converted to `System.IFormattable` or `System.FormattableString` (which implements `System.IFormattable`).</span></span>

<span data-ttu-id="ba1b0-152">Při použití tohoto převodu řetězcové hodnoty se skládá z interpolovaném řetězci.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-152">When this conversion is applied a string value is not composed from the interpolated string.</span></span> <span data-ttu-id="ba1b0-153">Místo toho instance `System.FormattableString` je vytvořen, jak je uvedeno v [interpolovaných řetězců](expressions.md#interpolated-strings).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-153">Instead an instance of `System.FormattableString` is created, as further described in [Interpolated strings](expressions.md#interpolated-strings).</span></span>

### <a name="implicit-nullable-conversions"></a><span data-ttu-id="ba1b0-154">Implicitní převod s možnou hodnotou Null</span><span class="sxs-lookup"><span data-stu-id="ba1b0-154">Implicit nullable conversions</span></span>

<span data-ttu-id="ba1b0-155">Předdefinované implicitních převodů, které pracují s typy hodnot neumožňující hodnotu lze také s formuláři s možnou hodnotou NULL z těchto typů.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-155">Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types.</span></span> <span data-ttu-id="ba1b0-156">Pro každý z předdefinovaných implicitní identity a číselných převodů, které provádějí převod z typu hodnotu Null `S` na typ hodnoty Null `T`, existují následující implicitní převody s možnou hodnotou NULL:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-156">For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type `S` to a non-nullable value type `T`, the following implicit nullable conversions exist:</span></span>

*  <span data-ttu-id="ba1b0-157">Implicitní převod z `S?` k `T?`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-157">An implicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="ba1b0-158">Implicitní převod z `S` k `T?`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-158">An implicit conversion from `S` to `T?`.</span></span>

<span data-ttu-id="ba1b0-159">Vyhodnocení implicitní převod s možnou hodnotou Null založené na základní převod z `S` k `T` probíhá následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-159">Evaluation of an implicit nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="ba1b0-160">Pokud je s možnou hodnotou Null převod ze `S?` k `T?`:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-160">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="ba1b0-161">Pokud zdrojová hodnota má hodnotu null (`HasValue` vlastnost má hodnotu false), výsledkem je hodnota null typu `T?`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-161">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="ba1b0-162">V opačném případě se převod vyhodnotí jako rozbalení z `S?` k `S`následovaný základní převod z `S` k `T`a po něm zabalení ([typy připouštějící hodnotu Null](types.md#nullable-types)) z `T` k `T?`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-162">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping ([Nullable types](types.md#nullable-types)) from `T` to `T?`.</span></span>

*  <span data-ttu-id="ba1b0-163">Při převodu s možnou hodnotou NULL z `S` k `T?`, převod se vyhodnotí jako základní převod z `S` k `T` za nímž následuje zabalení z `T` k `T?`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-163">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>

### <a name="null-literal-conversions"></a><span data-ttu-id="ba1b0-164">Literál null převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-164">Null literal conversions</span></span>

<span data-ttu-id="ba1b0-165">Implicitní převod `null` literál na libovolný typ s možnou hodnotou Null.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-165">An implicit conversion exists from the `null` literal to any nullable type.</span></span> <span data-ttu-id="ba1b0-166">Tento převod vytvoří hodnotu null ([typy připouštějící hodnotu Null](types.md#nullable-types)) daného typu s možnou hodnotou Null.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-166">This conversion produces the null value ([Nullable types](types.md#nullable-types)) of the given nullable type.</span></span>

### <a name="implicit-reference-conversions"></a><span data-ttu-id="ba1b0-167">Odkaz na implicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-167">Implicit reference conversions</span></span>

<span data-ttu-id="ba1b0-168">Odkaz na implicitní převody jsou:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-168">The implicit reference conversions are:</span></span>

*  <span data-ttu-id="ba1b0-169">Z libovolného *reference_type* k `object` a `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-169">From any *reference_type* to `object` and `dynamic`.</span></span>
*  <span data-ttu-id="ba1b0-170">Z libovolného *class_type* `S` k libovolnému *class_type* `T`, k dispozici `S` je odvozen z `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-170">From any *class_type* `S` to any *class_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="ba1b0-171">Z libovolného *class_type* `S` k libovolnému *interface_type* `T`, k dispozici `S` implementuje `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-171">From any *class_type* `S` to any *interface_type* `T`, provided `S` implements `T`.</span></span>
*  <span data-ttu-id="ba1b0-172">Z libovolného *interface_type* `S` k libovolnému *interface_type* `T`, k dispozici `S` je odvozen z `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-172">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="ba1b0-173">Z *array_type* `S` s typem elementu `SE` do *array_type* `T` s typem elementu `TE`, pokud jsou splněny všechny z následujících akcí:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-173">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="ba1b0-174">`S` a `T` se liší pouze v typu elementu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-174">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="ba1b0-175">Jinými slovy `S` a `T` mít stejný počet rozměrů.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-175">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="ba1b0-176">Obě `SE` a `TE` jsou *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-176">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="ba1b0-177">Existuje implicitní referenční převod z `SE` k `TE`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-177">An implicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="ba1b0-178">Z libovolného *array_type* k `System.Array` a implementuje rozhraní.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-178">From any *array_type* to `System.Array` and the interfaces it implements.</span></span>
*  <span data-ttu-id="ba1b0-179">Jednorozměrné pole typu `S[]` k `System.Collections.Generic.IList<T>` a jeho základní rozhraní za předpokladu, že je implicitní identity nebo odkaz na převod z `S` k `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-179">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an implicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="ba1b0-180">Z libovolného *delegate_type* k `System.Delegate` a implementuje rozhraní.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-180">From any *delegate_type* to `System.Delegate` and the interfaces it implements.</span></span>
*  <span data-ttu-id="ba1b0-181">Z literál s hodnotou null k libovolnému *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-181">From the null literal to any *reference_type*.</span></span>
*  <span data-ttu-id="ba1b0-182">Z libovolného *reference_type* k *reference_type* `T` Pokud má implicitní identity nebo odkaz na převod na *reference_type* `T0` a `T0` má konverzi identity k `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-182">From any *reference_type* to a *reference_type* `T` if it has an implicit identity or reference conversion to a *reference_type* `T0` and `T0` has an identity conversion to `T`.</span></span>
*  <span data-ttu-id="ba1b0-183">Z libovolného *reference_type* na typ rozhraní nebo delegát `T` Pokud má implicitní převod identity nebo odkaz na typ rozhraní nebo delegát `T0` a `T0` je odchylka převoditelné ([ Převod variance](interfaces.md#variance-conversion)) k `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-183">From any *reference_type* to an interface or delegate type `T` if it has an implicit identity or reference conversion to an interface or delegate type `T0` and `T0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `T`.</span></span>
*  <span data-ttu-id="ba1b0-184">Implicitní převody zahrnující parametry typu, které jsou známé jako referenční typy.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-184">Implicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="ba1b0-185">Zobrazit [implicitních převodů zahrnující parametry typu](conversions.md#implicit-conversions-involving-type-parameters) podrobné informace o implicitní převody zahrnující parametry typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-185">See [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) for more details on implicit conversions involving type parameters.</span></span>

<span data-ttu-id="ba1b0-186">Odkaz na implicitní převody jsou tyto převody mezi *reference_type*, které můžete prověřené vždy úspěšné a proto vyžaduje žádné kontroly za běhu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-186">The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</span></span>

<span data-ttu-id="ba1b0-187">Převody odkazů, implicitní nebo explicitní, nikdy nezmění referenční identity objektu převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-187">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="ba1b0-188">Jinými slovy zatímco referenční převod může změnit typ odkazu, se nikdy nemění typem nebo hodnotou objektu, který se odkazuje.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-188">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="ba1b0-189">Zabalení převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-189">Boxing conversions</span></span>

<span data-ttu-id="ba1b0-190">Umožňuje převod na uzavřené určení *value_type* má být implicitně převeden na typ odkazu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-190">A boxing conversion permits a *value_type* to be implicitly converted to a reference type.</span></span> <span data-ttu-id="ba1b0-191">Existuje převod na uzavřené určení z libovolného *non_nullable_value_type* k `object` a `dynamic`do `System.ValueType` a k libovolnému *interface_type* implementované *non_ nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-191">A boxing conversion exists from any *non_nullable_value_type* to `object` and `dynamic`, to `System.ValueType` and to any *interface_type* implemented by the *non_nullable_value_type*.</span></span> <span data-ttu-id="ba1b0-192">Kromě *enum_type* lze převést na typ `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-192">Furthermore an *enum_type* can be converted to the type `System.Enum`.</span></span>

<span data-ttu-id="ba1b0-193">Existuje převod na uzavřené určení z *nullable_type* na typ odkazu, pokud a pouze v případě, že převod na uzavřené určení existuje ze základního *non_nullable_value_type* na typ odkazu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-193">A boxing conversion exists from a *nullable_type* to a reference type, if and only if a boxing conversion exists from the underlying *non_nullable_value_type* to the reference type.</span></span>

<span data-ttu-id="ba1b0-194">Typ hodnoty je zabalení převod na typ rozhraní `I` se jeho zabalení převod na typ rozhraní `I0` a `I0` má konverzi identity k `I`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-194">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="ba1b0-195">Hodnotový typ má zabalení převod na typ rozhraní `I` Pokud má zabalení převod na typ rozhraní nebo delegát `I0` a `I0` je odchylka převoditelné ([Variance převod](interfaces.md#variance-conversion)) k `I`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-195">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface or delegate type `I0` and `I0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `I`.</span></span>

<span data-ttu-id="ba1b0-196">Zabalení hodnotu *non_nullable_value_type* se skládá z přidělování instancí objektu a kopírování *value_type* hodnoty do této instance.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-196">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *value_type* value into that instance.</span></span> <span data-ttu-id="ba1b0-197">Jde použít boxing strukturu na typ `System.ValueType`, protože to je základní třída pro všechny struktury ([dědičnosti](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-197">A struct can be boxed to the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="ba1b0-198">Zabalení hodnotu *nullable_type* probíhá následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-198">Boxing a value of a *nullable_type* proceeds as follows:</span></span>

*  <span data-ttu-id="ba1b0-199">Pokud zdrojová hodnota má hodnotu null (`HasValue` vlastnost má hodnotu false), výsledek je nulový odkaz cílového typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-199">If the source value is null (`HasValue` property is false), the result is a null reference of the target type.</span></span>
*  <span data-ttu-id="ba1b0-200">V opačném případě výsledkem je odkaz na zabalený `T` vytvářené rozbalení a zabalení zdrojovou hodnotou.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-200">Otherwise, the result is a reference to a boxed `T` produced by unwrapping and boxing the source value.</span></span>

<span data-ttu-id="ba1b0-201">Zabalení převody jsou popsány dále v [zabalení převody](types.md#boxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-201">Boxing conversions are described further in [Boxing conversions](types.md#boxing-conversions).</span></span>

### <a name="implicit-dynamic-conversions"></a><span data-ttu-id="ba1b0-202">Implicitní převody na dynamický</span><span class="sxs-lookup"><span data-stu-id="ba1b0-202">Implicit dynamic conversions</span></span>

<span data-ttu-id="ba1b0-203">Implicitní převod dynamických existuje z výrazu typu `dynamic` na libovolný typ `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-203">An implicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="ba1b0-204">Převod je vázán dynamicky ([dynamické vazby](expressions.md#dynamic-binding)), což znamená, že implicitní převod bude hledat v době běhu z typu za běhu výraz, který má `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-204">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="ba1b0-205">Pokud se nenajde žádný převod, je vyvolána výjimka za běhu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-205">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="ba1b0-206">Všimněte si, že tento implicitní převod zdánlivě porušuje doporučení na začátku [implicitních převodů](conversions.md#implicit-conversions) implicitní převod by nikdy nezpůsobí výjimku.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-206">Note that this implicit conversion seemingly violates the advice in the beginning of [Implicit conversions](conversions.md#implicit-conversions) that an implicit conversion should never cause an exception.</span></span> <span data-ttu-id="ba1b0-207">Ale není převod samostatně, ale *hledání* převodu, která způsobí výjimku.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-207">However it is not the conversion itself, but the *finding* of the conversion that causes the exception.</span></span> <span data-ttu-id="ba1b0-208">Riziko výjimek za běhu je spojená s používáním dynamické vazby.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-208">The risk of run-time exceptions is inherent in the use of dynamic binding.</span></span> <span data-ttu-id="ba1b0-209">Pokud dynamické vazby převod není žádoucí, výraz může být nejprve převeden na `object`a potom do požadovaného typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-209">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="ba1b0-210">Následující příklad ukazuje dynamické implicitní převody:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-210">The following example illustrates implicit dynamic conversions:</span></span>

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

<span data-ttu-id="ba1b0-211">Přiřazení k `s2` a `i` i využívat implicitních převodů dynamické, kde je vazba operace pozastaveno do za běhu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-211">The assignments to `s2` and `i` both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time.</span></span> <span data-ttu-id="ba1b0-212">V době běhu, jsou požadována implicitní převody z typu za běhu `d`  --  `string` --do cílového typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-212">At run-time, implicit conversions are sought from the run-time type of `d` -- `string` -- to the target type.</span></span> <span data-ttu-id="ba1b0-213">Převod se nachází na `string` , ale nikoli k `int`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-213">A conversion is found to `string` but not to `int`.</span></span>

### <a name="implicit-constant-expression-conversions"></a><span data-ttu-id="ba1b0-214">Konstantní výraz implicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-214">Implicit constant expression conversions</span></span>

<span data-ttu-id="ba1b0-215">Konverzi implicitní konstantní výraz povoluje následující převody:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-215">An implicit constant expression conversion permits the following conversions:</span></span>

*  <span data-ttu-id="ba1b0-216">A *constant_expression* ([konstantní výrazy](expressions.md#constant-expressions)) typu `int` lze převést na typ `sbyte`, `byte`, `short`, `ushort`, `uint`, nebo `ulong`, zadaná hodnota *constant_expression* je v rozsahu cílového typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-216">A *constant_expression* ([Constant expressions](expressions.md#constant-expressions)) of type `int` can be converted to type `sbyte`, `byte`, `short`, `ushort`, `uint`, or `ulong`, provided the value of the *constant_expression* is within the range of the destination type.</span></span>
*  <span data-ttu-id="ba1b0-217">A *constant_expression* typu `long` lze převést na typ `ulong`, zadaná hodnota *constant_expression* není záporná.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-217">A *constant_expression* of type `long` can be converted to type `ulong`, provided the value of the *constant_expression* is not negative.</span></span>

### <a name="implicit-conversions-involving-type-parameters"></a><span data-ttu-id="ba1b0-218">Implicitní převody zahrnující parametry typu</span><span class="sxs-lookup"><span data-stu-id="ba1b0-218">Implicit conversions involving type parameters</span></span>

<span data-ttu-id="ba1b0-219">Existují následující implicitní převody pro daný typ parametru `T`:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-219">The following implicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="ba1b0-220">Z `T` se svou základní třídou efektivní `C`, z `T` na všechny základní třídy `C`a z `T` na libovolném rozhraní implementované `C`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-220">From `T` to its effective base class `C`, from `T` to any base class of `C`, and from `T` to any interface implemented by `C`.</span></span> <span data-ttu-id="ba1b0-221">AT za běhu, pokud `T` je typ hodnoty, je proveden převod, protože převod na uzavřené určení.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-221">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="ba1b0-222">V opačném případě je proveden převod jako implicitní převod odkazu nebo převod identity.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-222">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="ba1b0-223">Z `T` k typu rozhraní `I` v `T`nastaví efektivní rozhraní a z `T` všechny základní rozhraní `I`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-223">From `T` to an interface type `I` in `T`'s effective interface set and from `T` to any base interface of `I`.</span></span> <span data-ttu-id="ba1b0-224">AT za běhu, pokud `T` je typ hodnoty, je proveden převod, protože převod na uzavřené určení.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-224">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="ba1b0-225">V opačném případě je proveden převod jako implicitní převod odkazu nebo převod identity.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-225">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="ba1b0-226">Z `T` parametru typu `U`, k dispozici `T` závisí na `U` ([omezení parametru typu](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-226">From `T` to a type parameter `U`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="ba1b0-227">AT za běhu, pokud `U` je typ hodnoty, pak `T` a `U` nutně jsou stejného typu a převod provést.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-227">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="ba1b0-228">Jinak, pokud `T` je typ hodnoty, je proveden převod, protože převod na uzavřené určení.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-228">Otherwise, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="ba1b0-229">V opačném případě je proveden převod jako implicitní převod odkazu nebo převod identity.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-229">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="ba1b0-230">Z literál s hodnotou null pro `T`, k dispozici `T` je znám jako typ odkazu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-230">From the null literal to `T`, provided `T` is known to be a reference type.</span></span>
*  <span data-ttu-id="ba1b0-231">Z `T` na typ odkazu `I` Pokud má implicitní převod na typ odkazu `S0` a `S0` má konverzi identity k `S`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-231">From `T` to a reference type `I` if it has an implicit conversion to a reference type `S0` and `S0` has an identity conversion to `S`.</span></span> <span data-ttu-id="ba1b0-232">V době běhu provádí převod stejným způsobem jako převod `S0`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-232">At run-time the conversion is executed the same way as the conversion to `S0`.</span></span>
*  <span data-ttu-id="ba1b0-233">Z `T` k typu rozhraní `I` Pokud má implicitní převod na typ rozhraní nebo delegát `I0` a `I0` je odchylka převoditelné na `I` ([Variance převod](interfaces.md#variance-conversion) ).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-233">From `T` to an interface type `I` if it has an implicit conversion to an interface or delegate type `I0` and `I0` is variance-convertible to `I` ([Variance conversion](interfaces.md#variance-conversion)).</span></span> <span data-ttu-id="ba1b0-234">AT za běhu, pokud `T` je typ hodnoty, je proveden převod, protože převod na uzavřené určení.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-234">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="ba1b0-235">V opačném případě je proveden převod jako implicitní převod odkazu nebo převod identity.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-235">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="ba1b0-236">Pokud `T` je znám jako typ odkazu ([omezení parametru typu](classes.md#type-parameter-constraints)), všechny výše uvedené převody jsou klasifikovány jako odkaz na implicitní převody ([odkaz na implicitní převody](conversions.md#implicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-236">If `T` is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)), the conversions above are all classified as implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions)).</span></span> <span data-ttu-id="ba1b0-237">Pokud `T` není známé jako typ odkazu, převody výše jsou klasifikovány jako zabalení převody ([zabalení převody](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-237">If `T` is not known to be a reference type, the conversions above are classified as boxing conversions ([Boxing conversions](conversions.md#boxing-conversions)).</span></span>

### <a name="user-defined-implicit-conversions"></a><span data-ttu-id="ba1b0-238">Uživatelem definované implicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-238">User-defined implicit conversions</span></span>

<span data-ttu-id="ba1b0-239">Implicitní převod definovaný uživatelem se skládá z volitelné standardní implicitní převod, za nímž následuje spuštění uživatelem definované implicitní převod operátoru, za nímž následuje jiný volitelné standardní implicitní převod.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-239">A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion.</span></span> <span data-ttu-id="ba1b0-240">Přesná pravidla za vaše rozhodnutí vyzkoušet uživatelem definované implicitní převody jsou popsané v [zpracování uživatelem definované implicitní převody](conversions.md#processing-of-user-defined-implicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-240">The exact rules for evaluating user-defined implicit conversions are described in [Processing of user-defined implicit conversions](conversions.md#processing-of-user-defined-implicit-conversions).</span></span>

### <a name="anonymous-function-conversions-and-method-group-conversions"></a><span data-ttu-id="ba1b0-241">Anonymní funkce převody a převody skupiny – metoda</span><span class="sxs-lookup"><span data-stu-id="ba1b0-241">Anonymous function conversions and method group conversions</span></span>

<span data-ttu-id="ba1b0-242">Anonymní funkce a metody skupiny nemají typy samy o sobě, ale může být implicitně převeden na delegáta typy nebo typy stromu výrazu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-242">Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types.</span></span> <span data-ttu-id="ba1b0-243">Anonymní funkce převody jsou popsány podrobněji [převody anonymní funkce](conversions.md#anonymous-function-conversions) a metoda převody skupin v [Metoda skupiny převody](conversions.md#method-group-conversions).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-243">Anonymous function conversions are described in more detail in [Anonymous function conversions](conversions.md#anonymous-function-conversions) and method group conversions in [Method group conversions](conversions.md#method-group-conversions).</span></span>

## <a name="explicit-conversions"></a><span data-ttu-id="ba1b0-244">Explicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-244">Explicit conversions</span></span>

<span data-ttu-id="ba1b0-245">Následující převody jsou klasifikovány jako explicitní převody:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-245">The following conversions are classified as explicit conversions:</span></span>

*  <span data-ttu-id="ba1b0-246">Všechny implicitní převody.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-246">All implicit conversions.</span></span>
*  <span data-ttu-id="ba1b0-247">Explicitní číselné převody.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-247">Explicit numeric conversions.</span></span>
*  <span data-ttu-id="ba1b0-248">Výčet explicitní převody.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-248">Explicit enumeration conversions.</span></span>
*  <span data-ttu-id="ba1b0-249">Explicitní převody s možnou hodnotou Null.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-249">Explicit nullable conversions.</span></span>
*  <span data-ttu-id="ba1b0-250">Odkaz na explicitní převody.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-250">Explicit reference conversions.</span></span>
*  <span data-ttu-id="ba1b0-251">Explicitní rozhraní převody.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-251">Explicit interface conversions.</span></span>
*  <span data-ttu-id="ba1b0-252">Rozbalení převody.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-252">Unboxing conversions.</span></span>
*  <span data-ttu-id="ba1b0-253">Explicitní převody na dynamický</span><span class="sxs-lookup"><span data-stu-id="ba1b0-253">Explicit dynamic conversions</span></span>
*  <span data-ttu-id="ba1b0-254">Uživatelem definované explicitní převody.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-254">User-defined explicit conversions.</span></span>

<span data-ttu-id="ba1b0-255">Explicitní převody může dojít v výrazy přetypování ([výrazy přetypování](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-255">Explicit conversions can occur in cast expressions ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="ba1b0-256">Explicitní převody sada obsahuje všechny implicitní převody.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-256">The set of explicit conversions includes all implicit conversions.</span></span> <span data-ttu-id="ba1b0-257">To znamená, že jsou povolena výrazy přetypování redundantní.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-257">This means that redundant cast expressions are allowed.</span></span>

<span data-ttu-id="ba1b0-258">Explicitní převody, které nejsou implicitní převody jsou převody, které nelze prověřené vždy úspěšné, převody, které se ví, případně dojít ke ztrátě informací a převody mezi doménami dostatečně neliší na explicitní hodnoty typů zápis.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-258">The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</span></span>

### <a name="explicit-numeric-conversions"></a><span data-ttu-id="ba1b0-259">Explicitní číselné převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-259">Explicit numeric conversions</span></span>

<span data-ttu-id="ba1b0-260">Explicitní číselné převody jsou převody z *numeric_type* do jiného *numeric_type* pro kterou implicitní převod čísla ([implicitních číselných převodů](conversions.md#implicit-numeric-conversions)) ještě neexistuje:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-260">The explicit numeric conversions are the conversions from a *numeric_type* to another *numeric_type* for which an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) does not already exist:</span></span>

*  <span data-ttu-id="ba1b0-261">Z `sbyte` k `byte`, `ushort`, `uint`, `ulong`, nebo `char`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-261">From `sbyte` to `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="ba1b0-262">Z `byte` k `sbyte` a `char`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-262">From `byte` to `sbyte` and `char`.</span></span>
*  <span data-ttu-id="ba1b0-263">Z `short` k `sbyte`, `byte`, `ushort`, `uint`, `ulong`, nebo `char`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-263">From `short` to `sbyte`, `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="ba1b0-264">Z `ushort` k `sbyte`, `byte`, `short`, nebo `char`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-264">From `ushort` to `sbyte`, `byte`, `short`, or `char`.</span></span>
*  <span data-ttu-id="ba1b0-265">Z `int` k `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, nebo `char`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-265">From `int` to `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="ba1b0-266">Z `uint` k `sbyte`, `byte`, `short`, `ushort`, `int`, nebo `char`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-266">From `uint` to `sbyte`, `byte`, `short`, `ushort`, `int`, or `char`.</span></span>
*  <span data-ttu-id="ba1b0-267">Z `long` k `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, nebo `char`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-267">From `long` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="ba1b0-268">Z `ulong` k `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, nebo `char`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-268">From `ulong` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, or `char`.</span></span>
*  <span data-ttu-id="ba1b0-269">Z `char` k `sbyte`, `byte`, nebo `short`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-269">From `char` to `sbyte`, `byte`, or `short`.</span></span>
*  <span data-ttu-id="ba1b0-270">Z `float` k `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-270">From `float` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, or `decimal`.</span></span>
*  <span data-ttu-id="ba1b0-271">Z `double` k `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-271">From `double` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `decimal`.</span></span>
*  <span data-ttu-id="ba1b0-272">Z `decimal` k `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, nebo `double`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-272">From `decimal` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `double`.</span></span>

<span data-ttu-id="ba1b0-273">Protože explicitní převody zahrnují všechny implicitní a explicitní číselné převody, je vždy možné převést z některého *numeric_type* u kteréhokoli jiného *numeric_type* pomocí (výraz přetypování [Výrazy přetypování](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-273">Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any *numeric_type* to any other *numeric_type* using a cast expression ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="ba1b0-274">Explicitní číselné převody potenciálně dojít ke ztrátě informací nebo pravděpodobně způsobí vyvolání výjimky.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-274">The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown.</span></span> <span data-ttu-id="ba1b0-275">Explicitní číselný převod zpracováván následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-275">An explicit numeric conversion is processed as follows:</span></span>

*  <span data-ttu-id="ba1b0-276">Pro převod z celočíselného typu na jiný celočíselný typ, zpracování závisí na kontextu kontroly přetečení ([operátory zaškrtnuto a nezaškrtnuto](expressions.md#the-checked-and-unchecked-operators)) v desetinný převod umístit:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-276">For a conversion from an integral type to another integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="ba1b0-277">V `checked` kontextu, převod je úspěšný, pokud je hodnota zdrojového operandu v rozsahu cílového typu, ale vyvolá výjimku `System.OverflowException` Pokud hodnota zdrojového operandu je mimo rozsah cílového typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-277">In a `checked` context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a `System.OverflowException` if the value of the source operand is outside the range of the destination type.</span></span>
    * <span data-ttu-id="ba1b0-278">V `unchecked` kontextu, převod vždy úspěšná a probíhá následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-278">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="ba1b0-279">Pokud typ zdroje je větší než cílový typ, pak je rozdělená do zdrojové hodnoty se zahodí jeho "navíc" nejvýznamnější bity.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-279">If the source type is larger than the destination type, then the source value is truncated by discarding its "extra" most significant bits.</span></span> <span data-ttu-id="ba1b0-280">Výsledek je pak považován za hodnotu cílového typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-280">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="ba1b0-281">Pokud typ zdroje je menší než cílový typ, pak zdrojová hodnota je rozšířena o znaménko nebo nulou tak, aby se stejnou velikostí jako typ cíle.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-281">If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type.</span></span> <span data-ttu-id="ba1b0-282">Rozšířením znaménka se používá, pokud typ zdroje je podepsaný; nulové rozšíření se používá, pokud se zdrojový typ není podepsaný.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-282">Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned.</span></span> <span data-ttu-id="ba1b0-283">Výsledek je pak považován za hodnotu cílového typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-283">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="ba1b0-284">Pokud se stejnou velikostí jako cílový typ je typ zdrojového, zdrojová hodnota je považován za hodnotu cílového typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-284">If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</span></span>
*  <span data-ttu-id="ba1b0-285">Pro konverzi `decimal` na celočíselný typ, zdrojová hodnota zaokrouhlena směrem k nule na nejbližší celočíselnou hodnotu a bude toto celé číslo výsledku převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-285">For a conversion from `decimal` to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion.</span></span> <span data-ttu-id="ba1b0-286">Pokud je výsledný celočíselné hodnoty mimo rozsah cílového typu `System.OverflowException` je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-286">If the resulting integral value is outside the range of the destination type, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="ba1b0-287">Pro konverzi `float` nebo `double` na celočíselný typ, zpracování závisí na kontextu kontroly přetečení ([operátory zaškrtnuto a nezaškrtnuto](expressions.md#the-checked-and-unchecked-operators)) v desetinný převod umístit:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-287">For a conversion from `float` or `double` to an integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="ba1b0-288">V `checked` kontextu, převod probíhá následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-288">In a `checked` context, the conversion proceeds as follows:</span></span>
        * <span data-ttu-id="ba1b0-289">Pokud je hodnota operandu NaN nebo nekonečno, `System.OverflowException` je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-289">If the value of the operand is NaN or infinite, a `System.OverflowException` is thrown.</span></span>
        * <span data-ttu-id="ba1b0-290">V opačném případě zdrojového operandu je zaokrouhlena směrem k nule na nejbližší celočíselnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-290">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="ba1b0-291">Pokud je toto celé číslo v rozsahu cílového typu je tato hodnota výsledku převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-291">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="ba1b0-292">V opačném případě `System.OverflowException` je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-292">Otherwise, a `System.OverflowException` is thrown.</span></span>
    * <span data-ttu-id="ba1b0-293">V `unchecked` kontextu, převod vždy úspěšná a probíhá následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-293">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="ba1b0-294">Pokud je hodnota operandu NaN nebo nekonečno, je výsledkem převodu neurčené hodnota cílového typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-294">If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</span></span>
        * <span data-ttu-id="ba1b0-295">V opačném případě zdrojového operandu je zaokrouhlena směrem k nule na nejbližší celočíselnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-295">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="ba1b0-296">Pokud je toto celé číslo v rozsahu cílového typu je tato hodnota výsledku převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-296">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="ba1b0-297">V opačném případě výsledkem převodu je neurčené hodnota cílového typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-297">Otherwise, the result of the conversion is an unspecified value of the destination type.</span></span>
*  <span data-ttu-id="ba1b0-298">Pro převod z `double` k `float`, `double` hodnota je zaokrouhlená na nejbližší `float` hodnotu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-298">For a conversion from `double` to `float`, the `double` value is rounded to the nearest `float` value.</span></span> <span data-ttu-id="ba1b0-299">Pokud `double` hodnota je příliš malá, aby reprezentovala `float`, výsledek bude kladné nula nebo záporná nula.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-299">If the `double` value is too small to represent as a `float`, the result becomes positive zero or negative zero.</span></span> <span data-ttu-id="ba1b0-300">Pokud `double` hodnota je příliš velký, aby reprezentovala `float`, výsledkem bude nekonečno kladné nebo záporné nekonečno.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-300">If the `double` value is too large to represent as a `float`, the result becomes positive infinity or negative infinity.</span></span> <span data-ttu-id="ba1b0-301">Pokud `double` je hodnota typu NaN, vrácená hodnota je také NaN.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-301">If the `double` value is NaN, the result is also NaN.</span></span>
*  <span data-ttu-id="ba1b0-302">Pro převod z `float` nebo `double` k `decimal`, zdrojová hodnota je převedena na `decimal` vyjádření a zaokrouhlí na nejbližší číslo po 28 desetinné čárky v případě potřeby ([typem decimal](types.md#the-decimal-type)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-302">For a conversion from `float` or `double` to `decimal`, the source value is converted to `decimal` representation and rounded to the nearest number after the 28th decimal place if required ([The decimal type](types.md#the-decimal-type)).</span></span> <span data-ttu-id="ba1b0-303">Pokud zdrojová hodnota je příliš malá, aby reprezentovala `decimal`, výsledkem bude nule.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-303">If the source value is too small to represent as a `decimal`, the result becomes zero.</span></span> <span data-ttu-id="ba1b0-304">Pokud zdrojová hodnota NaN, nekonečno, nebo příliš velký, aby reprezentovala `decimal`, `System.OverflowException` je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-304">If the source value is NaN, infinity, or too large to represent as a `decimal`, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="ba1b0-305">Pro převod z `decimal` k `float` nebo `double`, `decimal` hodnota je zaokrouhlená na nejbližší `double` nebo `float` hodnotu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-305">For a conversion from `decimal` to `float` or `double`, the `decimal` value is rounded to the nearest `double` or `float` value.</span></span> <span data-ttu-id="ba1b0-306">Přestože tento převod může dojít ke ztrátě přesnosti, nikdy způsobí vyvolání výjimky.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-306">While this conversion may lose precision, it never causes an exception to be thrown.</span></span>

### <a name="explicit-enumeration-conversions"></a><span data-ttu-id="ba1b0-307">Výčet explicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-307">Explicit enumeration conversions</span></span>

<span data-ttu-id="ba1b0-308">Výčet explicitní převody jsou:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-308">The explicit enumeration conversions are:</span></span>

*  <span data-ttu-id="ba1b0-309">Z `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, nebo `decimal` do jakékoli *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-309">From `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal` to any *enum_type*.</span></span>
*  <span data-ttu-id="ba1b0-310">Z libovolného *enum_type* k `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-310">From any *enum_type* to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="ba1b0-311">Z libovolného *enum_type* u kteréhokoli jiného *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-311">From any *enum_type* to any other *enum_type*.</span></span>

<span data-ttu-id="ba1b0-312">Výčet explicitní převod mezi dvěma typy je zpracován považuje všechny zúčastněné *enum_type* jako základní typ, který *enum_type*a pak provádí implicitní nebo explicitní číselný převod mezi typy výsledný.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-312">An explicit enumeration conversion between two types is processed by treating any participating *enum_type* as the underlying type of that *enum_type*, and then performing an implicit or explicit numeric conversion between the resulting types.</span></span> <span data-ttu-id="ba1b0-313">Mějme například *enum_type* `E` s a nadřazený typ `int`, převod z `E` k `byte` zpracovávány jako explicitní číselný převod ([explicitní číselné převody](conversions.md#explicit-numeric-conversions)) z `int` k `byte`a převod z `byte` k `E` zpracovávány jako implicitní převod čísla ([implicitních číselných převodů](conversions.md#implicit-numeric-conversions)) z `byte` k `int`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-313">For example, given an *enum_type* `E` with and underlying type of `int`, a conversion from `E` to `byte` is processed as an explicit numeric conversion ([Explicit numeric conversions](conversions.md#explicit-numeric-conversions)) from `int` to `byte`, and a conversion from `byte` to `E` is processed as an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) from `byte` to `int`.</span></span>

### <a name="explicit-nullable-conversions"></a><span data-ttu-id="ba1b0-314">Explicitní převody s možnou hodnotou Null</span><span class="sxs-lookup"><span data-stu-id="ba1b0-314">Explicit nullable conversions</span></span>

<span data-ttu-id="ba1b0-315">***Explicitní převody s možnou hodnotou Null*** povolení předdefinované explicitních převodů, které pracují s typy hodnot neumožňující hodnotu lze použít také s možnou hodnotou Null formuláře z těchto typů.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-315">***Explicit nullable conversions*** permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types.</span></span> <span data-ttu-id="ba1b0-316">Pro každou z předdefinovaných explicitních převodů, které provádějí převod z typu hodnotu Null `S` na typ hodnoty Null `T` ([Identity převod](conversions.md#identity-conversion), [implicitních číselných převodů](conversions.md#implicit-numeric-conversions), [Výčet implicitní převody](conversions.md#implicit-enumeration-conversions), [explicitních číselných převodů](conversions.md#explicit-numeric-conversions), a [výčet explicitní převody](conversions.md#explicit-enumeration-conversions)), následující Existují převody s možnou hodnotou NULL:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-316">For each of the predefined explicit conversions that convert from a non-nullable value type `S` to a non-nullable value type `T` ([Identity conversion](conversions.md#identity-conversion), [Implicit numeric conversions](conversions.md#implicit-numeric-conversions), [Implicit enumeration conversions](conversions.md#implicit-enumeration-conversions), [Explicit numeric conversions](conversions.md#explicit-numeric-conversions), and [Explicit enumeration conversions](conversions.md#explicit-enumeration-conversions)), the following nullable conversions exist:</span></span>

*  <span data-ttu-id="ba1b0-317">Explicitní převod z `S?` k `T?`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-317">An explicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="ba1b0-318">Explicitní převod z `S` k `T?`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-318">An explicit conversion from `S` to `T?`.</span></span>
*  <span data-ttu-id="ba1b0-319">Explicitní převod z `S?` k `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-319">An explicit conversion from `S?` to `T`.</span></span>

<span data-ttu-id="ba1b0-320">Hodnocení s možnou hodnotou Null převodu založené na základní převod z `S` k `T` probíhá následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-320">Evaluation of a nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="ba1b0-321">Pokud je s možnou hodnotou Null převod ze `S?` k `T?`:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-321">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="ba1b0-322">Pokud zdrojová hodnota má hodnotu null (`HasValue` vlastnost má hodnotu false), výsledkem je hodnota null typu `T?`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-322">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="ba1b0-323">V opačném případě se převod vyhodnotí jako rozbalení z `S?` k `S`následovaný základní převod z `S` k `T`následovaný zabalení z `T` k `T?`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-323">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="ba1b0-324">Při převodu s možnou hodnotou NULL z `S` k `T?`, převod se vyhodnotí jako základní převod z `S` k `T` za nímž následuje zabalení z `T` k `T?`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-324">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="ba1b0-325">Při převodu s možnou hodnotou NULL z `S?` k `T`, převod se vyhodnotí jako rozbalení z `S?` k `S` následovaný základní převod z `S` k `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-325">If the nullable conversion is from `S?` to `T`, the conversion is evaluated as an unwrapping from `S?` to `S` followed by the underlying conversion from `S` to `T`.</span></span>

<span data-ttu-id="ba1b0-326">Všimněte si, že pokus o rozbalení povolenou vyvolá výjimku, pokud je hodnota `null`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-326">Note that an attempt to unwrap a nullable value will throw an exception if the value is `null`.</span></span>

### <a name="explicit-reference-conversions"></a><span data-ttu-id="ba1b0-327">Odkaz na explicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-327">Explicit reference conversions</span></span>

<span data-ttu-id="ba1b0-328">Odkaz na explicitní převody jsou:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-328">The explicit reference conversions are:</span></span>

*  <span data-ttu-id="ba1b0-329">Z `object` a `dynamic` u kteréhokoli jiného *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-329">From `object` and `dynamic` to any other *reference_type*.</span></span>
*  <span data-ttu-id="ba1b0-330">Z libovolného *class_type* `S` k libovolnému *class_type* `T`, k dispozici `S` je základní třídou `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-330">From any *class_type* `S` to any *class_type* `T`, provided `S` is a base class of `T`.</span></span>
*  <span data-ttu-id="ba1b0-331">Z libovolného *class_type* `S` k libovolnému *interface_type* `T`, k dispozici `S` není zapečetěná a k dispozici `S` neimplementuje `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-331">From any *class_type* `S` to any *interface_type* `T`, provided `S` is not sealed and provided `S` does not implement `T`.</span></span>
*  <span data-ttu-id="ba1b0-332">Z libovolného *interface_type* `S` k libovolnému *class_type* `T`, k dispozici `T` není zapečetěná, nebo k dispozici `T` implementuje `S`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-332">From any *interface_type* `S` to any *class_type* `T`, provided `T` is not sealed or provided `T` implements `S`.</span></span>
*  <span data-ttu-id="ba1b0-333">Z libovolného *interface_type* `S` k libovolnému *interface_type* `T`, k dispozici `S` není odvozen od `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-333">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is not derived from `T`.</span></span>
*  <span data-ttu-id="ba1b0-334">Z *array_type* `S` s typem elementu `SE` do *array_type* `T` s typem elementu `TE`, pokud jsou splněny všechny z následujících akcí:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-334">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="ba1b0-335">`S` a `T` se liší pouze v typu elementu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-335">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="ba1b0-336">Jinými slovy `S` a `T` mít stejný počet rozměrů.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-336">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="ba1b0-337">Obě `SE` a `TE` jsou *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-337">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="ba1b0-338">Explicitní odkaz na převod `SE` k `TE`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-338">An explicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="ba1b0-339">Z `System.Array` a rozhraní implementuje k libovolnému *array_type*.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-339">From `System.Array` and the interfaces it implements to any *array_type*.</span></span>
*  <span data-ttu-id="ba1b0-340">Jednorozměrné pole typu `S[]` k `System.Collections.Generic.IList<T>` a jeho základní rozhraní za předpokladu, že je převod explicitní odkaz `S` k `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-340">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an explicit reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="ba1b0-341">Z `System.Collections.Generic.IList<S>` a její základní rozhraní pro typ jednorozměrné pole `T[]`za předpokladu, že existuje explicitní převod identity nebo odkaz z `S` k `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-341">From `System.Collections.Generic.IList<S>` and its base interfaces to a single-dimensional array type `T[]`, provided that there is an explicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="ba1b0-342">Z `System.Delegate` a rozhraní implementuje k libovolnému *delegate_type*.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-342">From `System.Delegate` and the interfaces it implements to any *delegate_type*.</span></span>
*  <span data-ttu-id="ba1b0-343">Typ odkazu na typ odkazu z `T` se jeho konverzi explicitní odkaz na typ odkazu `T0` a `T0` má konverzi identity `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-343">From a reference type to a reference type `T` if it has an explicit reference conversion to a reference type `T0` and `T0` has an identity conversion `T`.</span></span>
*  <span data-ttu-id="ba1b0-344">Z typu odkazu na typ rozhraní nebo delegát `T` Pokud má konverzi explicitní odkaz na typ rozhraní nebo delegát `T0` a buď `T0` je odchylka převoditelné na `T` nebo `T` je Variance-lze převést na typ `T0` ([Variance převod](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-344">From a reference type to an interface or delegate type `T` if it has an explicit reference conversion to an interface or delegate type `T0` and either `T0` is variance-convertible to `T` or `T` is variance-convertible to `T0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>
*  <span data-ttu-id="ba1b0-345">Z `D<S1...Sn>` k `D<T1...Tn>` kde `D<X1...Xn>` je typem obecného delegátu `D<S1...Sn>` není kompatibilní s nebo stejný jako `D<T1...Tn>`a pro každý parametr typu `Xi` z `D` obsahuje následující:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-345">From `D<S1...Sn>` to `D<T1...Tn>` where `D<X1...Xn>` is a generic delegate type, `D<S1...Sn>` is not compatible with or identical to `D<T1...Tn>`, and for each type parameter `Xi` of `D` the following holds:</span></span>
    * <span data-ttu-id="ba1b0-346">Pokud `Xi` je neutrální, pak `Si` je stejný jako `Ti`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-346">If `Xi` is invariant, then `Si` is identical to `Ti`.</span></span>
    * <span data-ttu-id="ba1b0-347">Pokud `Xi` je kovariantní, pak je implicitní nebo explicitní identity nebo odkaz na převod pro z `Si` k `Ti`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-347">If `Xi` is covariant, then there is an implicit or explicit identity or reference conversion from `Si` to `Ti`.</span></span>
    * <span data-ttu-id="ba1b0-348">Pokud `Xi` je kontravariantní, pak `Si` a `Ti` jsou buď stejné nebo oba typy odkazů.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-348">If `Xi` is contravariant, then `Si` and `Ti` are either identical or both reference types.</span></span>
*  <span data-ttu-id="ba1b0-349">Explicitní převody zahrnující parametry typu, které jsou známé jako referenční typy.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-349">Explicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="ba1b0-350">Podrobné informace o explicitních převodů zahrnující parametry typu, najdete v článku [explicitních převodů zahrnující parametry typu](conversions.md#explicit-conversions-involving-type-parameters).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-350">For more details on explicit conversions involving type parameters, see [Explicit conversions involving type parameters](conversions.md#explicit-conversions-involving-type-parameters).</span></span>

<span data-ttu-id="ba1b0-351">Odkaz na explicitní převody jsou tyto převody mezi – typy odkazů, které vyžadují kontroly za běhu k zajištění, že jsou správné.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-351">The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</span></span>

<span data-ttu-id="ba1b0-352">Pro konverzi explicitní odkaz na úspěšné v době běhu musí být hodnota zdrojového operandu `null`, nebo skutečný typ objekt odkazovaný zadaným parametrem zdrojový operand musí být typ, který lze převést na typ cílového implicitní odkazem převod ([odkaz na implicitní převody](conversions.md#implicit-reference-conversions)) nebo převod na uzavřené určení ([zabalení převody](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-352">For an explicit reference conversion to succeed at run-time, the value of the source operand must be `null`, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions)) or boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)).</span></span> <span data-ttu-id="ba1b0-353">Pokud se nezdaří konverzi explicitní odkaz `System.InvalidCastException` je vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-353">If an explicit reference conversion fails, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="ba1b0-354">Převody odkazů, implicitní nebo explicitní, nikdy nezmění referenční identity objektu převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-354">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="ba1b0-355">Jinými slovy zatímco referenční převod může změnit typ odkazu, se nikdy nemění typem nebo hodnotou objektu, který se odkazuje.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-355">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="ba1b0-356">Rozbalení převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-356">Unboxing conversions</span></span>

<span data-ttu-id="ba1b0-357">Unboxingového převodu povoluje má být explicitně převeden na typ odkazu *value_type*.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-357">An unboxing conversion permits a reference type to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="ba1b0-358">Existuje unboxingového převodu z typů `object`, `dynamic` a `System.ValueType` k libovolnému *non_nullable_value_type*a z jakéhokoli *interface_type* k libovolnému *non_ nullable_value_type* , který implementuje *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-358">An unboxing conversion exists from the types `object`, `dynamic` and `System.ValueType` to any *non_nullable_value_type*, and from any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span> <span data-ttu-id="ba1b0-359">Dále zadejte `System.Enum` může být bez unboxingu na jakýkoli *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-359">Furthermore type `System.Enum` can be unboxed to any *enum_type*.</span></span>

<span data-ttu-id="ba1b0-360">Existuje unboxingového převodu z typu odkazu na *nullable_type* pokud existuje unboxingového převodu z typu odkazu k podkladovým *non_nullable_value_type* z  *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-360">An unboxing conversion exists from a reference type to a *nullable_type* if an unboxing conversion exists from the reference type to the underlying *non_nullable_value_type* of the *nullable_type*.</span></span>

<span data-ttu-id="ba1b0-361">Typ hodnoty `S` má unboxingového převodu z typu rozhraní `I` se jeho unboxingového převodu z typu rozhraní `I0` a `I0` má konverzi identity k `I`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-361">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="ba1b0-362">Typ hodnoty `S` má unboxingového převodu z typu rozhraní `I` Pokud má unboxingového převodu z typu rozhraní nebo delegát `I0` a buď `I0` je odchylka převoditelné na `I` nebo `I`je odchylka převoditelné na `I0` ([Variance převod](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-362">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface or delegate type `I0` and either `I0` is variance-convertible to `I` or `I` is variance-convertible to `I0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>

<span data-ttu-id="ba1b0-363">Operace rozbalení se skládá z nejdřív zkontrolovali, že se instance objektu je zabalený hodnotu daný *value_type*a potom kopírování hodnoty z instance.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-363">An unboxing operation consists of first checking that the object instance is a boxed value of the given *value_type*, and then copying the value out of the instance.</span></span> <span data-ttu-id="ba1b0-364">Odkaz s hodnotou null pro rozbalení *nullable_type* vytvoří hodnotu null *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-364">Unboxing a null reference to a *nullable_type* produces the null value of the *nullable_type*.</span></span> <span data-ttu-id="ba1b0-365">Struktura může být z typ bez unboxingu `System.ValueType`, protože to je základní třída pro všechny struktury ([dědičnosti](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-365">A struct can be unboxed from the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="ba1b0-366">Rozbalení převody jsou popsány dále v [rozbalení převody](types.md#unboxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-366">Unboxing conversions are described further in [Unboxing conversions](types.md#unboxing-conversions).</span></span>

### <a name="explicit-dynamic-conversions"></a><span data-ttu-id="ba1b0-367">Explicitní převody na dynamický</span><span class="sxs-lookup"><span data-stu-id="ba1b0-367">Explicit dynamic conversions</span></span>

<span data-ttu-id="ba1b0-368">Existuje explicitní převod dynamických z výrazu typu `dynamic` na libovolný typ `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-368">An explicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="ba1b0-369">Převod je vázán dynamicky ([dynamické vazby](expressions.md#dynamic-binding)), což znamená, že explicitní převod bude hledat v době běhu z typu za běhu výraz, který má `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-369">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="ba1b0-370">Pokud se nenajde žádný převod, je vyvolána výjimka za běhu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-370">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="ba1b0-371">Pokud dynamické vazby převod není žádoucí, výraz může být nejprve převeden na `object`a potom do požadovaného typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-371">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="ba1b0-372">Předpokládejme, že je definován následující třídy:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-372">Assume the following class is defined:</span></span>
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

<span data-ttu-id="ba1b0-373">Následující příklad ukazuje explicitní převody dynamické:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-373">The following example illustrates explicit dynamic conversions:</span></span>
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

<span data-ttu-id="ba1b0-374">Nejlepší převod `o` k `C` se nachází v době kompilace bude konverzi explicitní odkaz.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-374">The best conversion of `o` to `C` is found at compile-time to be an explicit reference conversion.</span></span> <span data-ttu-id="ba1b0-375">To se nezdaří, v době běhu, protože `"1"` není ve skutečnosti `C`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-375">This fails at run-time, because `"1"` is not in fact a `C`.</span></span> <span data-ttu-id="ba1b0-376">Převod `d` k `C` však jako explicitní převod dynamického, je pozastavený, aby za běhu, ve kterém uživatelem definovaný převod z typu za běhu `d`  --  `string` – na `C` nenajde, a proběhne úspěšně.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-376">The conversion of `d` to `C` however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of `d` -- `string` -- to `C` is found, and succeeds.</span></span>

### <a name="explicit-conversions-involving-type-parameters"></a><span data-ttu-id="ba1b0-377">Explicitní převody zahrnující parametry typu</span><span class="sxs-lookup"><span data-stu-id="ba1b0-377">Explicit conversions involving type parameters</span></span>

<span data-ttu-id="ba1b0-378">Pro daný typ parametru existují následující explicitní převody `T`:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-378">The following explicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="ba1b0-379">Ze základní třídy efektivní `C` z `T` k `T` a žádné základní třídy `C` k `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-379">From the effective base class `C` of `T` to `T` and from any base class of `C` to `T`.</span></span> <span data-ttu-id="ba1b0-380">AT za běhu, pokud `T` je typ hodnoty, je proveden převod, protože unboxingového převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-380">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="ba1b0-381">V opačném případě je převod proveden, protože explicitní odkaz ani převod identity.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-381">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="ba1b0-382">Z libovolného typu rozhraní na `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-382">From any interface type to `T`.</span></span> <span data-ttu-id="ba1b0-383">AT za běhu, pokud `T` je typ hodnoty, je proveden převod, protože unboxingového převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-383">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="ba1b0-384">V opačném případě je převod proveden, protože explicitní odkaz ani převod identity.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-384">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="ba1b0-385">Z `T` k libovolnému *interface_type* `I` Pokud již není implicitní převod z `T` k `I`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-385">From `T` to any *interface_type* `I` provided there is not already an implicit conversion from `T` to `I`.</span></span> <span data-ttu-id="ba1b0-386">AT za běhu, pokud `T` je typ hodnoty, je proveden převod, protože za nímž následuje konverzi explicitní odkaz převod na uzavřené určení.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-386">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion.</span></span> <span data-ttu-id="ba1b0-387">V opačném případě je převod proveden, protože explicitní odkaz ani převod identity.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-387">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="ba1b0-388">Z parametru typu `U` k `T`, k dispozici `T` závisí na `U` ([omezení parametru typu](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-388">From a type parameter `U` to `T`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="ba1b0-389">AT za běhu, pokud `U` je typ hodnoty, pak `T` a `U` nutně jsou stejného typu a převod provést.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-389">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="ba1b0-390">Jinak, pokud `T` je typ hodnoty, je proveden převod, protože unboxingového převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-390">Otherwise, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="ba1b0-391">V opačném případě je převod proveden, protože explicitní odkaz ani převod identity.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-391">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="ba1b0-392">Pokud `T` je známé jako typ odkazu, převody výše jsou všechny klasifikované jako odkaz na explicitní převody ([odkaz na explicitní převody](conversions.md#explicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-392">If `T` is known to be a reference type, the conversions above are all classified as explicit reference conversions ([Explicit reference conversions](conversions.md#explicit-reference-conversions)).</span></span> <span data-ttu-id="ba1b0-393">Pokud `T` není známé jako typ odkazu, převody výše jsou klasifikovány jako rozbalení převody ([rozbalení převody](conversions.md#unboxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-393">If `T` is not known to be a reference type, the conversions above are classified as unboxing conversions ([Unboxing conversions](conversions.md#unboxing-conversions)).</span></span>

<span data-ttu-id="ba1b0-394">Výše uvedených pravidel není povoleno přímé explicitní převod z parametrem bez omezení typu na typ jiného typu než rozhraní, který může být překvapivé.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-394">The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising.</span></span> <span data-ttu-id="ba1b0-395">Důvod pro toto pravidlo je zabránit nejasnostem a ujistěte se, sémantika tyto převody vymazat.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-395">The reason for this rule is to prevent confusion and make the semantics of such conversions clear.</span></span> <span data-ttu-id="ba1b0-396">Předpokládejme například následující deklaraci:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-396">For example, consider the following declaration:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

<span data-ttu-id="ba1b0-397">Pokud s přímým přístupem explicitního převodu `t` k `int` byly převody povoleny, snadno očekávat, který `X<int>.F(7)` vracel `7L`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-397">If the direct explicit conversion of `t` to `int` were permitted, one might easily expect that `X<int>.F(7)` would return `7L`.</span></span> <span data-ttu-id="ba1b0-398">Však stejně, protože standardních číselných převodů považují pouze pokud jsou známé typy jako číselné během vazby.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-398">However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time.</span></span> <span data-ttu-id="ba1b0-399">Pokud chcete mít sémantiku clear výše uvedeném příkladu musí být zapsán:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-399">In order to make the semantics clear, the above example must instead be written:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

<span data-ttu-id="ba1b0-400">Tento kód se zkompiluje teď ale provádění `X<int>.F(7)` by pak vyvolat výjimku v době běhu, protože zabalené `int` přímo se nedá převést `long`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-400">This code will now compile but executing `X<int>.F(7)` would then throw an exception at run-time, since a boxed `int` cannot be converted directly to a `long`.</span></span>

### <a name="user-defined-explicit-conversions"></a><span data-ttu-id="ba1b0-401">Uživatelem definované explicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-401">User-defined explicit conversions</span></span>

<span data-ttu-id="ba1b0-402">Uživatelem definované explicitní převod se skládá z volitelné standardní explicitní převod, za nímž následuje spuštění uživatelem definované implicitní nebo explicitní převod operátoru, za nímž následuje jiný volitelné standardní explicitní převod.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-402">A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion.</span></span> <span data-ttu-id="ba1b0-403">Přesná pravidla za vaše rozhodnutí vyzkoušet uživatelem definované explicitní převody jsou popsané v [zpracování uživatelem definované explicitní převody](conversions.md#processing-of-user-defined-explicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-403">The exact rules for evaluating user-defined explicit conversions are described in [Processing of user-defined explicit conversions](conversions.md#processing-of-user-defined-explicit-conversions).</span></span>

## <a name="standard-conversions"></a><span data-ttu-id="ba1b0-404">Standardní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-404">Standard conversions</span></span>

<span data-ttu-id="ba1b0-405">Standardní převody jsou tyto předem definované převody, které může být součástí uživatelem definovaný převod.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-405">The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</span></span>

### <a name="standard-implicit-conversions"></a><span data-ttu-id="ba1b0-406">Standardní implicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-406">Standard implicit conversions</span></span>

<span data-ttu-id="ba1b0-407">Následující implicitní převody jsou klasifikovány jako standardní implicitní převody:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-407">The following implicit conversions are classified as standard implicit conversions:</span></span>

*  <span data-ttu-id="ba1b0-408">Převody identity ([Identity převod](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="ba1b0-408">Identity conversions ([Identity conversion](conversions.md#identity-conversion))</span></span>
*  <span data-ttu-id="ba1b0-409">Implicitní číselné převody ([implicitních číselných převodů](conversions.md#implicit-numeric-conversions))</span><span class="sxs-lookup"><span data-stu-id="ba1b0-409">Implicit numeric conversions ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions))</span></span>
*  <span data-ttu-id="ba1b0-410">Implicitní převod s možnou hodnotou Null ([implicitní převody typu s možnou hodnotou Null](conversions.md#implicit-nullable-conversions))</span><span class="sxs-lookup"><span data-stu-id="ba1b0-410">Implicit nullable conversions ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions))</span></span>
*  <span data-ttu-id="ba1b0-411">Odkaz na implicitní převody ([odkaz na implicitní převody](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="ba1b0-411">Implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
*  <span data-ttu-id="ba1b0-412">Zabalení převody ([zabalení převody](conversions.md#boxing-conversions))</span><span class="sxs-lookup"><span data-stu-id="ba1b0-412">Boxing conversions ([Boxing conversions](conversions.md#boxing-conversions))</span></span>
*  <span data-ttu-id="ba1b0-413">Konstantní výraz implicitní převody ([implicitních převodů dynamické](conversions.md#implicit-dynamic-conversions))</span><span class="sxs-lookup"><span data-stu-id="ba1b0-413">Implicit constant expression conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions))</span></span>
*  <span data-ttu-id="ba1b0-414">Implicitní převody zahrnující parametry typu ([implicitních převodů zahrnující parametry typu](conversions.md#implicit-conversions-involving-type-parameters))</span><span class="sxs-lookup"><span data-stu-id="ba1b0-414">Implicit conversions involving type parameters ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters))</span></span>

<span data-ttu-id="ba1b0-415">Standardní implicitní převody výslovně vyloučit implicitní převody definované uživatelem.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-415">The standard implicit conversions specifically exclude user-defined implicit conversions.</span></span>

### <a name="standard-explicit-conversions"></a><span data-ttu-id="ba1b0-416">Standardní explicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-416">Standard explicit conversions</span></span>

<span data-ttu-id="ba1b0-417">Standardní explicitní převody jsou všechny standardní implicitní převody plus podmnožinu explicitních převodů, pro které existuje opačné standardní implicitní převod.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-417">The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists.</span></span> <span data-ttu-id="ba1b0-418">Jinými slovy, pokud standardní implicitní existuje převod z typu `A` na typ `B`, pak existuje standardní explicitní převod z typu `A` na typ `B` z typu `B` na typ `A`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-418">In other words, if a standard implicit conversion exists from a type `A` to a type `B`, then a standard explicit conversion exists from type `A` to type `B` and from type `B` to type `A`.</span></span>

## <a name="user-defined-conversions"></a><span data-ttu-id="ba1b0-419">Uživatelem definované převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-419">User-defined conversions</span></span>

<span data-ttu-id="ba1b0-420">C# umožňuje rozšířen o předdefinované implicitní a explicitní převody ***uživatelem definované převody***.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-420">C# allows the pre-defined implicit and explicit conversions to be augmented by ***user-defined conversions***.</span></span> <span data-ttu-id="ba1b0-421">Uživatelem definované převody jsou zavedené službou deklarace operátorů převodu ([operátory převodu](classes.md#conversion-operators)) v typy třídy a struktury.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-421">User-defined conversions are introduced by declaring conversion operators ([Conversion operators](classes.md#conversion-operators)) in class and struct types.</span></span>

### <a name="permitted-user-defined-conversions"></a><span data-ttu-id="ba1b0-422">Povolené uživatelem definované převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-422">Permitted user-defined conversions</span></span>

<span data-ttu-id="ba1b0-423">C# umožňuje pouze určité uživatelem definované převody na deklarovat.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-423">C# permits only certain user-defined conversions to be declared.</span></span> <span data-ttu-id="ba1b0-424">Zejména není možné předefinovat již existující implicitní nebo explicitní převod.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-424">In particular, it is not possible to redefine an already existing implicit or explicit conversion.</span></span>

<span data-ttu-id="ba1b0-425">Pro typ daného zdroje `S` a cílový typ `T`, pokud `S` nebo `T` jsou typy s možnou hodnotou Null, umožní `S0` a `T0` odkazovat na základní typy, jinak `S0` a `T0` jsou rovno `S` a `T` v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-425">For a given source type `S` and target type `T`, if `S` or `T` are nullable types, let `S0` and `T0` refer to their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span> <span data-ttu-id="ba1b0-426">Třídy nebo struktury je povolené pro deklaraci převod z typu zdrojové `S` s cílovým typem `T` pouze v případě, že jsou splněny všechny z následujících akcí:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-426">A class or struct is permitted to declare a conversion from a source type `S` to a target type `T` only if all of the following are true:</span></span>

*  <span data-ttu-id="ba1b0-427">`S0` a `T0` jsou různé typy.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-427">`S0` and `T0` are different types.</span></span>
*  <span data-ttu-id="ba1b0-428">Buď `S0` nebo `T0` je typ třídy nebo struktury, ve kterém probíhá deklarace operátoru.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-428">Either `S0` or `T0` is the class or struct type in which the operator declaration takes place.</span></span>
*  <span data-ttu-id="ba1b0-429">Ani `S0` ani `T0` je *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-429">Neither `S0` nor `T0` is an *interface_type*.</span></span>
*  <span data-ttu-id="ba1b0-430">S výjimkou uživatelem definované převody neexistuje převod z `S` k `T` nebo z `T` k `S`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-430">Excluding user-defined conversions, a conversion does not exist from `S` to `T` or from `T` to `S`.</span></span>

<span data-ttu-id="ba1b0-431">Omezení, které platí pro uživatelem definované převody jsou popsané dále v [operátory převodu](classes.md#conversion-operators).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-431">The restrictions that apply to user-defined conversions are discussed further in [Conversion operators](classes.md#conversion-operators).</span></span>

### <a name="lifted-conversion-operators"></a><span data-ttu-id="ba1b0-432">Operátory převodu zdvižené</span><span class="sxs-lookup"><span data-stu-id="ba1b0-432">Lifted conversion operators</span></span>

<span data-ttu-id="ba1b0-433">Zadaný operátor uživatelsky definovaný převod, který převede hodnotu Null typu `S` na typ hodnoty Null `T`, ***zrušeno vs. operátor převodu*** existuje které převádí z `S?` k `T?`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-433">Given a user-defined conversion operator that converts from a non-nullable value type `S` to a non-nullable value type `T`, a ***lifted conversion operator*** exists that converts from `S?` to `T?`.</span></span> <span data-ttu-id="ba1b0-434">Tohoto operátoru převodu zdvižené provádí rozbalení z `S?` k `S` za nímž následuje uživatelsky definovaný převod z `S` k `T` za nímž následuje zabalení z `T` k `T?`, s tím rozdílem, že s hodnotou null Vážíme si toho `S?` převáděn přímo s hodnotou null `T?`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-434">This lifted conversion operator performs an unwrapping from `S?` to `S` followed by the user-defined conversion from `S` to `T` followed by a wrapping from `T` to `T?`, except that a null valued `S?` converts directly to a null valued `T?`.</span></span>

<span data-ttu-id="ba1b0-435">Operátor převodu zdvižené má stejné implicitní nebo explicitní zařazení jako jeho základní operátor uživatelsky definovaný převod.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-435">A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.</span></span> <span data-ttu-id="ba1b0-436">Termín "uživatelsky definovaný převod" platí pro použití uživatelsky definovaná a zrušeno vs. operátory převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-436">The term "user-defined conversion" applies to the use of both user-defined and lifted conversion operators.</span></span>

### <a name="evaluation-of-user-defined-conversions"></a><span data-ttu-id="ba1b0-437">Hodnocení produktu uživatelem definované převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-437">Evaluation of user-defined conversions</span></span>

<span data-ttu-id="ba1b0-438">Uživatelem definovaná konverze z jeho typu, volá se, převede hodnotu ***typ zdroje***, do jiného typu, volá se ***cílový typ***.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-438">A user-defined conversion converts a value from its type, called the ***source type***, to another type, called the ***target type***.</span></span> <span data-ttu-id="ba1b0-439">Centra vyhodnocení uživatelsky definovaný převod na vyhledávání ***nejspecifičtější*** uživatelsky definovaný převod operátor pro konkrétní zdrojovými a cílovými typy.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-439">Evaluation of a user-defined conversion centers on finding the ***most specific*** user-defined conversion operator for the particular source and target types.</span></span> <span data-ttu-id="ba1b0-440">Toto rozhodnutí je rozdělená do několika kroků:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-440">This determination is broken into several steps:</span></span>

*  <span data-ttu-id="ba1b0-441">Najít sadu tříd a struktur, ze kterého budou považovat za uživatelsky definovaný převod operátorů.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-441">Finding the set of classes and structs from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="ba1b0-442">Tato sada obsahuje typ zdroje a jejích základních tříd a cílový typ a jejích základních tříd (s implicitní předpokladů, že pouze třídy a struktury můžete deklarovat operátory definované uživatelem, a zda máte typy bez třídy žádné základní třídy).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-442">This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes).</span></span> <span data-ttu-id="ba1b0-443">Pro účely tohoto kroku, pokud je zdrojový nebo cílový typ *nullable_type*, jejich základní typ je místo toho použít.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-443">For the purposes of this step, if either the source or target type is a *nullable_type*, their underlying type is used instead.</span></span>
*  <span data-ttu-id="ba1b0-444">Z této sady typů určující, které definované uživatelem a zrušeno vs. operátory převodu se dají použít.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-444">From that set of types, determining which user-defined and lifted conversion operators are applicable.</span></span> <span data-ttu-id="ba1b0-445">Pro operátor převodu fungovaly, musí být možné provést standardní převod ([standardní převody](conversions.md#standard-conversions)) od zdrojového typu na operand musí být typu operátor a je možné provést standardní převod z typu výsledek operátoru do cílového typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-445">For a conversion operator to be applicable, it must be possible to perform a standard conversion ([Standard conversions](conversions.md#standard-conversions)) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</span></span>
*  <span data-ttu-id="ba1b0-446">Ze sady použít operátory definované uživatelem, určující, které operátor je jednoznačně nejkonkrétnější.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-446">From the set of applicable user-defined operators, determining which operator is unambiguously the most specific.</span></span> <span data-ttu-id="ba1b0-447">Obecně řečeno nejspecifičtější operátor je operátor, který je typem operandu "nejblíže" typ zdroje a jehož typ výsledku je "co nejblíž koncovým" cílového typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-447">In general terms, the most specific operator is the operator whose operand type is "closest" to the source type and whose result type is "closest" to the target type.</span></span> <span data-ttu-id="ba1b0-448">Uživatelem definovaný převod operátory jsou upřednostňované nad operátory zdvižené převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-448">User-defined conversion operators are preferred over lifted conversion operators.</span></span> <span data-ttu-id="ba1b0-449">Přesná pravidla pro stanovení nejspecifičtější operátor uživatelsky definovaný převod jsou definovány v následující části.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-449">The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</span></span>

<span data-ttu-id="ba1b0-450">Po určení nejspecifičtější operátor uživatelsky definovaný převod aktuální provádění uživatelsky definovaný převod zahrnuje až tři kroky:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-450">Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</span></span>

*  <span data-ttu-id="ba1b0-451">Standardní převod z typu zdroje na operand typu operátoru převodu uživatelem nebo zdvižené provádění nejprve v případě potřeby.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-451">First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</span></span>
*  <span data-ttu-id="ba1b0-452">V dalším kroku volání operátoru převodu uživatelem nebo zdvižené k provedení převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-452">Next, invoking the user-defined or lifted conversion operator to perform the conversion.</span></span>
*  <span data-ttu-id="ba1b0-453">Nakonec pokud je to nutné, provádění standardní převod z typu výsledek operátoru převodu uživatelem nebo zdvižené na cílový typ.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-453">Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</span></span>

<span data-ttu-id="ba1b0-454">Vyhodnocení uživatelsky definovaný převod nikdy zahrnuje více než jeden operátor uživatelem nebo zdvižené převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-454">Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator.</span></span> <span data-ttu-id="ba1b0-455">Jinými slovy, převod z typu `S` na typ `T` nikdy nejprve provede uživatelem definovaná konverze z `S` k `X` a následné provádění uživatelem definovaná konverze z `X` k `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-455">In other words, a conversion from type `S` to type `T` will never first execute a user-defined conversion from `S` to `X` and then execute a user-defined conversion from `X` to `T`.</span></span>

<span data-ttu-id="ba1b0-456">Přesné definice vyhodnocování uživatelsky definované explicitní nebo implicitní převody jsou uvedeny v následujících částech.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-456">Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections.</span></span> <span data-ttu-id="ba1b0-457">Ujistěte se, definice pomocí následujících podmínek:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-457">The definitions make use of the following terms:</span></span>

*  <span data-ttu-id="ba1b0-458">Pokud standardní implicitní převod ([standardní implicitní převody](conversions.md#standard-implicit-conversions)) existuje z typu `A` na typ `B`a pokud `A` ani `B` jsou *interface_type*s, pak `A` je označen jako ***vlastněný*** `B`, a `B` se říká, že ***zahrnovat*** `A`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-458">If a standard implicit conversion ([Standard implicit conversions](conversions.md#standard-implicit-conversions)) exists from a type `A` to a type `B`, and if neither `A` nor `B` are *interface_type*s, then `A` is said to be ***encompassed by*** `B`, and `B` is said to ***encompass*** `A`.</span></span>
*  <span data-ttu-id="ba1b0-459">***Nejvíce včetně typu*** sadu typů je jeden typ, který zahrnuje všechny typy v sadě.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-459">The ***most encompassing type*** in a set of types is the one type that encompasses all other types in the set.</span></span> <span data-ttu-id="ba1b0-460">Pokud žádné jednoho typu zahrnuje všechny ostatní typy, sada nemá nejvíce včetně typ.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-460">If no single type encompasses all other types, then the set has no most encompassing type.</span></span> <span data-ttu-id="ba1b0-461">V mnohem intuitivnější podmínky nejvíce včetně typ je typ "největší" v sadě – jeden typ, ke kterému všech ostatních typů lze implicitně převést.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-461">In more intuitive terms, the most encompassing type is the "largest" type in the set—the one type to which each of the other types can be implicitly converted.</span></span>
*  <span data-ttu-id="ba1b0-462">***Nejvíce zahrnuta typ*** sadu typů je jeden typ, který je zahrnut ve všech ostatních typů v sadě.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-462">The ***most encompassed type*** in a set of types is the one type that is encompassed by all other types in the set.</span></span> <span data-ttu-id="ba1b0-463">Pokud žádný jediný typ je zahrnut ve všech ostatních typů, pak sada má již nejvíce zahrnuta typu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-463">If no single type is encompassed by all other types, then the set has no most encompassed type.</span></span> <span data-ttu-id="ba1b0-464">V mnohem intuitivnější podmínky nejvíce encompassed typ je typ "nejmenší" v sadě – jeden typ, který lze implicitně převést na všech ostatních typů.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-464">In more intuitive terms, the most encompassed type is the "smallest" type in the set—the one type that can be implicitly converted to each of the other types.</span></span>

### <a name="processing-of-user-defined-implicit-conversions"></a><span data-ttu-id="ba1b0-465">Zpracování uživatelského implicitních převodů</span><span class="sxs-lookup"><span data-stu-id="ba1b0-465">Processing of user-defined implicit conversions</span></span>

<span data-ttu-id="ba1b0-466">Implicitní převod z typu uživatelem definované `S` na typ `T` zpracování následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-466">A user-defined implicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="ba1b0-467">Určete typy `S0` a `T0`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-467">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="ba1b0-468">Pokud `S` nebo `T` jsou typy s možnou hodnotou Null, `S0` a `T0` se jejich základní typy, v opačném případě `S0` a `T0` rovnají `S` a `T` v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-468">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="ba1b0-469">Najít sadu typů, `D`, ze kterých uživatelsky definovaný převod operátory se budou považovat za.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-469">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="ba1b0-470">Tato sada se skládá z `S0` (Pokud `S0` je třída nebo struktura), základní třídy `S0` (Pokud `S0` je třída), a `T0` (Pokud `T0` je třída nebo struktura).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-470">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), and `T0` (if `T0` is a class or struct).</span></span>
*  <span data-ttu-id="ba1b0-471">Najít sadu operátory použitelné uživatelsky definovaná a zdvižené převodu `U`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-471">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="ba1b0-472">Tato sada obsahuje operátory definované uživatelem a zdvižené implicitní převod deklaroval třídy nebo struktury v `D` převod z typu včetně `S` na typ vlastněný `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-472">This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing `S` to a type encompassed by `T`.</span></span> <span data-ttu-id="ba1b0-473">Pokud `U` je prázdný, převod není definován a dojde k chybě kompilace.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-473">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="ba1b0-474">Najít co nejspecifičtější typ. zdroj `SX`, operátorů v `U`:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-474">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="ba1b0-475">Pokud je libovolná z operátorů v `U` převést `S`, pak `SX` je `S`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-475">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="ba1b0-476">V opačném případě `SX` je nejvíce encompassed typ v kombinovanou sadu typů zdrojů operátorů v `U`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-476">Otherwise, `SX` is the most encompassed type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="ba1b0-477">Pokud právě jeden nejvíce zahrnuta typ nebyl nalezen, pak převod je nejednoznačný a dojde k chybě kompilace.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-477">If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="ba1b0-478">Najít co nejspecifičtější typ. cílové `TX`, operátorů v `U`:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-478">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="ba1b0-479">Pokud je libovolná z operátorů v `U` převést na `T`, pak `TX` je `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-479">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="ba1b0-480">V opačném případě `TX` je nejvíce včetně typu v kombinovanou sadu cílové typy operátorů v `U`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-480">Otherwise, `TX` is the most encompassing type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="ba1b0-481">Pokud nelze najít největší včetně právě jeden typ, pak převod je nejednoznačný a dojde k chybě kompilace.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-481">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="ba1b0-482">Najdete nejspecifičtější operátor převodu:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-482">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="ba1b0-483">Pokud `U` obsahuje přesně jeden uživatelsky definovaný převod operátor, který převede z `SX` k `TX`, pak toto je nejspecifičtější operátoru převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-483">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="ba1b0-484">Jinak, pokud `U` obsahuje přesně jeden operátor zdvižené převodu, která převede z `SX` k `TX`, pak toto je nejspecifičtější operátoru převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-484">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="ba1b0-485">V opačném případě převod je nejednoznačný a dojde k chybě kompilace.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-485">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="ba1b0-486">Nakonec použijte převod:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-486">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="ba1b0-487">Pokud `S` není `SX`, pak standardní implicitní převod z `S` k `SX` provádí.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-487">If `S` is not `SX`, then a standard implicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="ba1b0-488">Nejspecifičtější operátor převodu je vyvolána k převodu z `SX` k `TX`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-488">The most specific conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="ba1b0-489">Pokud `TX` není `T`, pak standardní implicitní převod z `TX` k `T` provádí.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-489">If `TX` is not `T`, then a standard implicit conversion from `TX` to `T` is performed.</span></span>

### <a name="processing-of-user-defined-explicit-conversions"></a><span data-ttu-id="ba1b0-490">Zpracování uživatelem definované explicitní převody</span><span class="sxs-lookup"><span data-stu-id="ba1b0-490">Processing of user-defined explicit conversions</span></span>

<span data-ttu-id="ba1b0-491">Uživatelem definované explicitní převod z typu `S` na typ `T` zpracování následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-491">A user-defined explicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="ba1b0-492">Určete typy `S0` a `T0`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-492">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="ba1b0-493">Pokud `S` nebo `T` jsou typy s možnou hodnotou Null, `S0` a `T0` se jejich základní typy, v opačném případě `S0` a `T0` rovnají `S` a `T` v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-493">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="ba1b0-494">Najít sadu typů, `D`, ze kterých uživatelsky definovaný převod operátory se budou považovat za.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-494">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="ba1b0-495">Tato sada se skládá z `S0` (Pokud `S0` je třída nebo struktura), základní třídy `S0` (Pokud `S0` je třída), `T0` (Pokud `T0` je třída nebo struktura) a základní třídy `T0` (Pokud `T0`je třída).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-495">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), `T0` (if `T0` is a class or struct), and the base classes of `T0` (if `T0` is a class).</span></span>
*  <span data-ttu-id="ba1b0-496">Najít sadu operátory použitelné uživatelsky definovaná a zdvižené převodu `U`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-496">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="ba1b0-497">Tato sada sestává z uživatelem definované a zdvižené implicitní nebo explicitní operátory převodu deklaroval třídy nebo struktury v `D` , převést z typu zahrnující nebo vlastněný `S` na typ zahrnující nebo vlastněný `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-497">This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing or encompassed by `S` to a type encompassing or encompassed by `T`.</span></span> <span data-ttu-id="ba1b0-498">Pokud `U` je prázdný, převod není definován a dojde k chybě kompilace.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-498">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="ba1b0-499">Najít co nejspecifičtější typ. zdroj `SX`, operátorů v `U`:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-499">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="ba1b0-500">Pokud je libovolná z operátorů v `U` převést `S`, pak `SX` je `S`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-500">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="ba1b0-501">Jinak, pokud je libovolná z operátorů v `U` převést z typů, které zahrnují `S`, pak `SX` je nejvíce encompassed typ v kombinovanou sadu typů zdrojů těchto operátorů.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-501">Otherwise, if any of the operators in `U` convert from types that encompass `S`, then `SX` is the most encompassed type in the combined set of source types of those operators.</span></span> <span data-ttu-id="ba1b0-502">Bez většiny zahrnuta najdete typ, pak převod je nejednoznačný a dojde k chybě kompilace.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-502">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="ba1b0-503">V opačném případě `SX` je nejvíce včetně typu v kombinovanou sadu typů zdrojů operátorů v `U`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-503">Otherwise, `SX` is the most encompassing type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="ba1b0-504">Pokud nelze najít největší včetně právě jeden typ, pak převod je nejednoznačný a dojde k chybě kompilace.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-504">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="ba1b0-505">Najít co nejspecifičtější typ. cílové `TX`, operátorů v `U`:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-505">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="ba1b0-506">Pokud je libovolná z operátorů v `U` převést na `T`, pak `TX` je `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-506">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="ba1b0-507">Jinak, pokud je libovolná z operátorů v `U` převod na typy, které jsou zahrnuté ve `T`, pak `TX` je nejvíce včetně typu v kombinovanou sadu cílové typy těchto operátorů.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-507">Otherwise, if any of the operators in `U` convert to types that are encompassed by `T`, then `TX` is the most encompassing type in the combined set of target types of those operators.</span></span> <span data-ttu-id="ba1b0-508">Pokud nelze najít největší včetně právě jeden typ, pak převod je nejednoznačný a dojde k chybě kompilace.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-508">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="ba1b0-509">V opačném případě `TX` je nejvíce encompassed typ v kombinovanou sadu cílové typy operátorů v `U`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-509">Otherwise, `TX` is the most encompassed type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="ba1b0-510">Bez většiny zahrnuta najdete typ, pak převod je nejednoznačný a dojde k chybě kompilace.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-510">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="ba1b0-511">Najdete nejspecifičtější operátor převodu:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-511">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="ba1b0-512">Pokud `U` obsahuje přesně jeden uživatelsky definovaný převod operátor, který převede z `SX` k `TX`, pak toto je nejspecifičtější operátoru převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-512">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="ba1b0-513">Jinak, pokud `U` obsahuje přesně jeden operátor zdvižené převodu, která převede z `SX` k `TX`, pak toto je nejspecifičtější operátoru převodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-513">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="ba1b0-514">V opačném případě převod je nejednoznačný a dojde k chybě kompilace.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-514">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="ba1b0-515">Nakonec použijte převod:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-515">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="ba1b0-516">Pokud `S` není `SX`, pak standardní explicitní převod z `S` k `SX` provádí.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-516">If `S` is not `SX`, then a standard explicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="ba1b0-517">Operátor nejspecifičtější uživatelem definovaného převodu je vyvolána k převodu z `SX` k `TX`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-517">The most specific user-defined conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="ba1b0-518">Pokud `TX` není `T`, pak standardní explicitní převod z `TX` k `T` provádí.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-518">If `TX` is not `T`, then a standard explicit conversion from `TX` to `T` is performed.</span></span>

## <a name="anonymous-function-conversions"></a><span data-ttu-id="ba1b0-519">Převody anonymní funkce</span><span class="sxs-lookup"><span data-stu-id="ba1b0-519">Anonymous function conversions</span></span>

<span data-ttu-id="ba1b0-520">*Anonymous_method_expression* nebo *lambda_expression* klasifikovaný jako anonymní funkce ([výrazy anonymní funkce](expressions.md#anonymous-function-expressions)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-520">An *anonymous_method_expression* or *lambda_expression* is classified as an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)).</span></span> <span data-ttu-id="ba1b0-521">Výraz nemá typ, ale může být implicitně převeden na typ kompatibilní delegáta nebo typu stromu výrazu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-521">The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type.</span></span> <span data-ttu-id="ba1b0-522">Konkrétně anonymní funkci `F` je kompatibilní s typem delegáta `D` k dispozici:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-522">Specifically, an anonymous function `F` is compatible with a delegate type `D` provided:</span></span>

*  <span data-ttu-id="ba1b0-523">Pokud `F` obsahuje *anonymous_function_signature*, pak `D` a `F` mají stejný počet parametrů.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-523">If `F` contains an *anonymous_function_signature*, then `D` and `F` have the same number of parameters.</span></span>
*  <span data-ttu-id="ba1b0-524">Pokud `F` neobsahuje *anonymous_function_signature*, pak `D` může mít nula nebo více parametrů typu, pokud žádný parametr `D` má `out` modifikátor parametru.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-524">If `F` does not contain an *anonymous_function_signature*, then `D` may have zero or more parameters of any type, as long as no parameter of `D` has the `out` parameter modifier.</span></span>
*  <span data-ttu-id="ba1b0-525">Pokud `F` má seznam parametrů explicitně, každý parametr `D` má stejný typ a modifikátory jako odpovídající parametr v `F`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-525">If `F` has an explicitly typed parameter list, each parameter in `D` has the same type and modifiers as the corresponding parameter in `F`.</span></span>
*  <span data-ttu-id="ba1b0-526">Pokud `F` má seznam implicitně typované parametrů, `D` nemá žádné `ref` nebo `out` parametry.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-526">If `F` has an implicitly typed parameter list, `D` has no `ref` or `out` parameters.</span></span>
*  <span data-ttu-id="ba1b0-527">Pokud tělo `F` je výraz a buď `D` má `void` návratový typ nebo `F` je asynchronní a `D` má návratový typ `Task`, pak když jednotlivé parametry nástroje `F` je uveden typ odpovídající parametr v `D`, text `F` je platný výraz (wrt [výrazy](expressions.md)), který by byl povolen jako *statement_expression* ([Příkazy výrazů](statements.md#expression-statements)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-527">If the body of `F` is an expression, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that would be permitted as a *statement_expression* ([Expression statements](statements.md#expression-statements)).</span></span>
*  <span data-ttu-id="ba1b0-528">Pokud tělo `F` je blok příkazů a buď `D` má `void` návratový typ nebo `F` je asynchronní a `D` má návratový typ `Task`, pak když jednotlivé parametry nástroje `F` je uveden typ odpovídající parametr v `D`, text `F` je platný příkaz blok (wrt [bloky](statements.md#blocks)) v které ne `return` příkaz Určuje výraz.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-528">If the body of `F` is a statement block, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) in which no `return` statement specifies an expression.</span></span>
*  <span data-ttu-id="ba1b0-529">Pokud tělo `F` pracuje, výrazem, a *buď* `F` je jiné asynchronní a `D` má návratový typ jiný než void `T`, *nebo* `F` je asynchronní a `D` má návratový typ `Task<T>`, pak když jednotlivé parametry nástroje `F` je uveden typ odpovídající parametr v `D`, text `F` je platný výraz (wrt [ Výrazy](expressions.md)), který je implicitně převést na `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-529">If the body of `F` is an expression, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that is implicitly convertible to `T`.</span></span>
*  <span data-ttu-id="ba1b0-530">Pokud tělo `F` je blok příkazů a *buď* `F` je jiné asynchronní a `D` má návratový typ jiný než void `T`, *nebo* `F` je asynchronní a `D` má návratový typ `Task<T>`, pak když jednotlivé parametry nástroje `F` je uveden typ odpovídající parametr v `D`, text `F` je platný příkaz blok (wrt [bloky ](statements.md#blocks)) s není dostupný koncový bod, ve nichž každý `return` příkaz Určuje výraz, který je implicitně převést na `T`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-530">If the body of `F` is a statement block, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) with a non-reachable end point in which each `return` statement specifies an expression that is implicitly convertible to `T`.</span></span>

<span data-ttu-id="ba1b0-531">Za účelem zkrácení, tato část používá zkratka pro typy úloh `Task` a `Task<T>` ([asynchronních funkcí](classes.md#async-functions)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-531">For the purpose of brevity, this section uses the short form for the task types `Task` and `Task<T>` ([Async functions](classes.md#async-functions)).</span></span>

<span data-ttu-id="ba1b0-532">Výraz lambda `F` je kompatibilní s typu stromu výrazu `Expression<D>` Pokud `F` kompatibilní s typem delegáta `D`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-532">A lambda expression `F` is compatible with an expression tree type `Expression<D>` if `F` is compatible with the delegate type `D`.</span></span> <span data-ttu-id="ba1b0-533">Všimněte si, že to neplatí pro anonymní metody, pouze výrazy lambda.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-533">Note that this does not apply to anonymous methods, only lambda expressions.</span></span>

<span data-ttu-id="ba1b0-534">Některé výrazy lambda nejde převést na typy stromu výrazu: I v případě, převod *existuje*, selže v době kompilace.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-534">Certain lambda expressions cannot be converted to expression tree types: Even though the conversion *exists*, it fails at compile-time.</span></span> <span data-ttu-id="ba1b0-535">To je v případě, pokud výraz lambda:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-535">This is the case if the lambda expression:</span></span>

*  <span data-ttu-id="ba1b0-536">Má *bloku* textu</span><span class="sxs-lookup"><span data-stu-id="ba1b0-536">Has a *block* body</span></span>
*  <span data-ttu-id="ba1b0-537">Obsahuje operátory jednoduchého a složeného přiřazení</span><span class="sxs-lookup"><span data-stu-id="ba1b0-537">Contains simple or compound assignment operators</span></span>
*  <span data-ttu-id="ba1b0-538">Obsahuje výraz dynamické vazby</span><span class="sxs-lookup"><span data-stu-id="ba1b0-538">Contains a dynamically bound expression</span></span>
*  <span data-ttu-id="ba1b0-539">Je asynchronní</span><span class="sxs-lookup"><span data-stu-id="ba1b0-539">Is async</span></span>

<span data-ttu-id="ba1b0-540">Následující příklady použití typu obecného delegátu `Func<A,R>` která představuje funkci, která přebírá argument typu `A` a vrátí hodnotu typu `R`:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-540">The examples that follow use a generic delegate type `Func<A,R>` which represents a function that takes an argument of type `A` and returns a value of type `R`:</span></span>
```csharp
delegate R Func<A,R>(A arg);
```

<span data-ttu-id="ba1b0-541">V přiřazení</span><span class="sxs-lookup"><span data-stu-id="ba1b0-541">In the assignments</span></span>
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
<span data-ttu-id="ba1b0-542">parametry a návratovým typem každý anonymní funkce se stanoví z typu proměnné, ke kterému je přiřazena anonymní funkce.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-542">the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</span></span>

<span data-ttu-id="ba1b0-543">První přiřazení úspěšně převede anonymní funkce na typ delegáta `Func<int,int>` vzhledem k tomu, že pokud `x` je daný typ `int`, `x+1` je platný výraz, který je implicitně převést na typ `int`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-543">The first assignment successfully converts the anonymous function to the delegate type `Func<int,int>` because, when `x` is given type `int`, `x+1` is a valid expression that is implicitly convertible to type `int`.</span></span>

<span data-ttu-id="ba1b0-544">Podobně, druhé přiřazení úspěšně převede anonymní funkce na typ delegáta `Func<int,double>` protože výsledek `x+1` (typu `int`) je implicitně převést na typ `double`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-544">Likewise, the second assignment successfully converts the anonymous function to the delegate type `Func<int,double>` because the result of `x+1` (of type `int`) is implicitly convertible to type `double`.</span></span>

<span data-ttu-id="ba1b0-545">Ale třetí přiřazení je chyba kompilace, protože když `x` je daný typ `double`, výsledek `x+1` (typu `double`) není implicitně převést na typ `int`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-545">However, the third assignment is a compile-time error because, when `x` is given type `double`, the result of `x+1` (of type `double`) is not implicitly convertible to type `int`.</span></span>

<span data-ttu-id="ba1b0-546">Čtvrtý přiřazení úspěšně převede anonymní asynchronní funkce na typ delegáta `Func<int, Task<int>>` protože výsledek `x+1` (typu `int`) implicitně převést na typ výsledku `int` typu úloh `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-546">The fourth assignment successfully converts the anonymous async function to the delegate type `Func<int, Task<int>>` because the result of `x+1` (of type `int`) is implicitly convertible to the result type `int` of the task type `Task<int>`.</span></span>

<span data-ttu-id="ba1b0-547">Anonymní funkce může ovlivnit rozlišení přetížení a účastnit odvození typu proměnné.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-547">Anonymous functions may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="ba1b0-548">Zobrazit [funkce členy](expressions.md#function-members) další podrobnosti.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-548">See [Function members](expressions.md#function-members) for further details.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a><span data-ttu-id="ba1b0-549">Hodnocení produktu anonymní funkce převody na typy delegátů</span><span class="sxs-lookup"><span data-stu-id="ba1b0-549">Evaluation of anonymous function conversions to delegate types</span></span>

<span data-ttu-id="ba1b0-550">Převod na typ delegáta anonymní funkce vytvoří instanci delegáta, který odkazuje na anonymní funkce a (pravděpodobně prázdná) sadu zachycené vnější proměnné, které jsou aktivní v době vyhodnocení.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-550">Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation.</span></span> <span data-ttu-id="ba1b0-551">Když je vyvolán delegát, provede se tělo anonymní funkce.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-551">When the delegate is invoked, the body of the anonymous function is executed.</span></span> <span data-ttu-id="ba1b0-552">Kód v těle je prováděn pomocí sady zachycené vnější proměnné odkazovat na delegáta.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-552">The code in the body is executed using the set of captured outer variables referenced by the delegate.</span></span>

<span data-ttu-id="ba1b0-553">Seznam vyvolání delegáta vytvořenými anonymní funkci obsahuje jednu položku.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-553">The invocation list of a delegate produced from an anonymous function contains a single entry.</span></span> <span data-ttu-id="ba1b0-554">Přesné cílového objektu a cílové metody delegáta nejsou specifikována.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-554">The exact target object and target method of the delegate are unspecified.</span></span> <span data-ttu-id="ba1b0-555">Zejména neurčená, jestli je cílový objekt delegáta `null`, `this` hodnotu nadřazeného členské funkce nebo některý objekt.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-555">In particular, it is unspecified whether the target object of the delegate is `null`, the `this` value of the enclosing function member, or some other object.</span></span>

<span data-ttu-id="ba1b0-556">Převody sémanticky identické anonymní funkce (pravděpodobně prázdná) stejnou sadou zachycené vnější proměnné instance stejné typy delegátů jsou povolené (ale není nutné) se vraťte stejnou instanci delegáta.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-556">Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance.</span></span> <span data-ttu-id="ba1b0-557">Termín sémanticky identické se zde používá k znamená, že spuštění anonymní funkce, ve všech případech se vytvoří stejný účinek zadaný stejné argumenty.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-557">The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments.</span></span> <span data-ttu-id="ba1b0-558">Toto pravidlo povoluje následující optimalizovat kód.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-558">This rule permits code such as the following to be optimized.</span></span>

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

<span data-ttu-id="ba1b0-559">Protože dvou delegátů anonymní funkce mají stejné (prázdné) sadu zachycené vnější proměnné, protože jsou sémanticky stejné anonymní funkce, kompilátor je oprávněny mít delegáty odkazovat na stejnou cílovou metodu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-559">Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method.</span></span> <span data-ttu-id="ba1b0-560">Ve skutečnosti kompilátor smí vracet velmi stejnou instanci delegáta oba výrazy anonymní funkce.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-560">Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a><span data-ttu-id="ba1b0-561">Hodnocení produktu anonymní funkce převody na typy stromu výrazů</span><span class="sxs-lookup"><span data-stu-id="ba1b0-561">Evaluation of anonymous function conversions to expression tree types</span></span>

<span data-ttu-id="ba1b0-562">Anonymní funkce Převod do typu stromu výrazu vytváří strom výrazu ([typy stromu výrazů](types.md#expression-tree-types)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-562">Conversion of an anonymous function to an expression tree type produces an expression tree ([Expression tree types](types.md#expression-tree-types)).</span></span> <span data-ttu-id="ba1b0-563">Přesněji řečeno vyhodnocení anonymní funkce převodu vede k vytváření objektovou strukturu, která reprezentuje strukturu těchto anonymní samotné funkce.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-563">More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself.</span></span> <span data-ttu-id="ba1b0-564">Přesné strukturu stromu výrazů, jakož i přesný postup pro vytváření, je definován implementací.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-564">The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</span></span>

### <a name="implementation-example"></a><span data-ttu-id="ba1b0-565">Příklad implementace</span><span class="sxs-lookup"><span data-stu-id="ba1b0-565">Implementation example</span></span>

<span data-ttu-id="ba1b0-566">Tato část popisuje možnou implementaci anonymní funkce převody z hlediska jiné konstrukce jazyka C#.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-566">This section describes a possible implementation of anonymous function conversions in terms of other C# constructs.</span></span> <span data-ttu-id="ba1b0-567">Implementace je zde popsáno, je založená na stejné zásady použít kompilátor jazyka Microsoft C#, ale nejsou v žádném smyslu mandátem implementace, ani je jediné možné.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-567">The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible.</span></span> <span data-ttu-id="ba1b0-568">Pouze stručně uvádí jako jejich přesné sémantika je mimo rozsah této specifikace převody na stromy výrazů.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-568">It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</span></span>

<span data-ttu-id="ba1b0-569">Zbývající část této části obsahuje několik příkladů kódu, který obsahuje anonymní funkce s různými charakteristikami.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-569">The remainder of this section gives several examples of code that contains anonymous functions with different characteristics.</span></span> <span data-ttu-id="ba1b0-570">Pro každý příklad je k dispozici odpovídající překlad do kódu, který používá jenom jiné konstrukce jazyka C#.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-570">For each example, a corresponding translation to code that uses only other C# constructs is provided.</span></span> <span data-ttu-id="ba1b0-571">V příkladech identifikátor `D` se předpokládá, že podle představují následující typ delegátu:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-571">In the examples, the identifier `D` is assumed by represent the following delegate type:</span></span>
```csharp
public delegate void D();
```

<span data-ttu-id="ba1b0-572">Nejjednodušší forma anonymní funkce je ten, který zachycuje žádné vnější proměnné:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-572">The simplest form of an anonymous function is one that captures no outer variables:</span></span>
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

<span data-ttu-id="ba1b0-573">To lze přeložit na instanci delegáta, který odkazuje na generovaný kompilátorem statické metody, ve kterém je umístí kód anonymní funkce:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-573">This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:</span></span>
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

<span data-ttu-id="ba1b0-574">Anonymní funkce v následujícím příkladu odkazuje na členy instance `this`:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-574">In the following example, the anonymous function references instance members of `this`:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

<span data-ttu-id="ba1b0-575">To lze přeložit na metodu instance generovaný kompilátorem obsahující kód anonymní funkce:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-575">This can be translated to a compiler generated instance method containing the code of the anonymous function:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

<span data-ttu-id="ba1b0-576">V tomto příkladu anonymní funkce zaznamenává místní proměnnou:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-576">In this example, the anonymous function captures a local variable:</span></span>
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

<span data-ttu-id="ba1b0-577">Doba života lokální proměnné musí teď rozšíří do alespoň životnost delegáta anonymní funkce.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-577">The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate.</span></span> <span data-ttu-id="ba1b0-578">Toho lze dosáhnout pomocí "zvedání" místní proměnné do pole třídy generovaný kompilátorem.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-578">This can be achieved by "hoisting" the local variable into a field of a compiler generated class.</span></span> <span data-ttu-id="ba1b0-579">Vytvoření instance lokální proměnné ([instance lokálních proměnných](expressions.md#instantiation-of-local-variables)) pak odpovídá vytvoření instance třídy generované kompilátorem a přístup k místní proměnné odpovídá přístup k poli v instanci třídy generované kompilátorem.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-579">Instantiation of the local variable ([Instantiation of local variables](expressions.md#instantiation-of-local-variables)) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class.</span></span> <span data-ttu-id="ba1b0-580">Anonymní funkce navíc změní metodu instance třídy generované kompilátorem:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-580">Furthermore, the anonymous function becomes an instance method of the compiler generated class:</span></span>
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

<span data-ttu-id="ba1b0-581">Nakonec následující anonymní funkce zachytávání `this` a také dvě lokální proměnné s jinou životnost:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-581">Finally, the following anonymous function captures `this` as well as two local variables with different lifetimes:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

<span data-ttu-id="ba1b0-582">Tady je vytvořená třída generovaný kompilátorem příkazu for each blok, ve kterých místní hodnoty jsou zachyceny tak, aby místní hodnoty v různé bloky mají nezávislé životnosti.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-582">Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes.</span></span> <span data-ttu-id="ba1b0-583">Instance `__Locals2`, třída generovaný kompilátorem pro vnitřní příkaz blok obsahuje místní proměnná `z` a pole, které odkazuje na instanci `__Locals1`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-583">An instance of `__Locals2`, the compiler generated class for the inner statement block, contains the local variable `z` and a field that references an instance of `__Locals1`.</span></span>  <span data-ttu-id="ba1b0-584">Instance `__Locals1`, třída generovaný kompilátorem pro blok vnější příkazů obsahuje místní proměnná `y` a pole, které odkazuje `this` nadřazeného člena funkce.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-584">An instance of `__Locals1`, the compiler generated class for the outer statement block, contains the local variable `y` and a field that references `this` of the enclosing function member.</span></span> <span data-ttu-id="ba1b0-585">S těmito datovými strukturami, je možné dosáhnout všechna zachytit vnější proměnné prostřednictvím instance `__Local2`, a kód anonymní funkce je tedy možné implementovat jako metodu instance této třídy.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-585">With these data structures it is possible to reach all captured outer variables through an instance of `__Local2`, and the code of the anonymous function can thus be implemented as an instance method of that class.</span></span>

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

<span data-ttu-id="ba1b0-586">Zde použít k zachycení lokálních proměnných stejný postup lze také při převodu anonymní funkce na stromy výrazů: Odkazy na objekty generovaný kompilátorem mohou být uloženy ve stromu výrazů a přístup k místní proměnné může být reprezentována jako pole k přistupuje na tyto objekty.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-586">The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects.</span></span> <span data-ttu-id="ba1b0-587">Výhodou tohoto přístupu je, že umožňuje "zdvižené" místní proměnné sdílen delegáty a stromů výrazů.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-587">The advantage of this approach is that it allows the "lifted" local variables to be shared between delegates and expression trees.</span></span>

## <a name="method-group-conversions"></a><span data-ttu-id="ba1b0-588">Převody skupiny – metoda</span><span class="sxs-lookup"><span data-stu-id="ba1b0-588">Method group conversions</span></span>

<span data-ttu-id="ba1b0-589">Implicitní převod ([implicitních převodů](conversions.md#implicit-conversions)) existuje ze skupiny – metoda ([výrazu klasifikace](expressions.md#expression-classifications)) na typ delegáta kompatibilní.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-589">An implicit conversion ([Implicit conversions](conversions.md#implicit-conversions)) exists from a method group ([Expression classifications](expressions.md#expression-classifications)) to a compatible delegate type.</span></span> <span data-ttu-id="ba1b0-590">Zadaný typ delegáta `D` a výraz `E` , který je klasifikován jako skupinu metod, existuje implicitní převod z `E` k `D` Pokud `E` obsahuje alespoň jednu metodu, která lze použít v jeho (normální formuláře [Použitelná funkce člena](expressions.md#applicable-function-member)) na seznam argumentů vytvořený použitím typů parametrů a modifikátory `D`, jak je popsáno v následujícím.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-590">Given a delegate type `D` and an expression `E` that is classified as a method group, an implicit conversion exists from `E` to `D` if `E` contains at least one method that is applicable in its normal form ([Applicable function member](expressions.md#applicable-function-member)) to an argument list constructed by use of the parameter types and modifiers of `D`, as described in the following.</span></span>

<span data-ttu-id="ba1b0-591">Kompilace aplikace převodu ze skupiny metoda `E` typu delegátu `D` je popsaná v následující.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-591">The compile-time application of a conversion from a method group `E` to a delegate type `D` is described in the following.</span></span> <span data-ttu-id="ba1b0-592">Všimněte si, že existenci implicitní převod z `E` k `D` nezaručuje, že aplikace za kompilace převodu bude úspěšné bez chyb.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-592">Note that the existence of an implicit conversion from `E` to `D` does not guarantee that the compile-time application of the conversion will succeed without error.</span></span>

*  <span data-ttu-id="ba1b0-593">Jedinou metodu `M` je vybrána odpovídající volání metody ([volání metod](expressions.md#method-invocations)) ve formátu `E(A)`, s těmito změnami:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-593">A single method `M` is selected corresponding to a method invocation ([Method invocations](expressions.md#method-invocations)) of the form `E(A)`, with the following modifications:</span></span>
    * <span data-ttu-id="ba1b0-594">Seznam argumentů `A` je seznamem výrazů, každý klasifikovaný jako proměnnou a s typem a modifikátor (`ref` nebo `out`) příslušného parametru v *formal_parameter_list* z `D`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-594">The argument list `A` is a list of expressions, each classified as a variable and with the type and modifier (`ref` or `out`) of the corresponding parameter in the *formal_parameter_list* of `D`.</span></span>
    * <span data-ttu-id="ba1b0-595">Metody Release candidate považovat za jsou jenom metody, které se dají použít v jejich normálním formuláře ([použitelná funkce člena](expressions.md#applicable-function-member)), není nastavení platných pouze v jejich rozšířené formuláře.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-595">The candidate methods considered are only those methods that are applicable in their normal form ([Applicable function member](expressions.md#applicable-function-member)), not those applicable only in their expanded form.</span></span>
*  <span data-ttu-id="ba1b0-596">Pokud algoritmus [volání metod](expressions.md#method-invocations) dojde k chybě, dojde k chybě v době kompilace.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-596">If the algorithm of [Method invocations](expressions.md#method-invocations) produces an error, then a compile-time error occurs.</span></span> <span data-ttu-id="ba1b0-597">V opačném případě algoritmus vytvoří jeden nejlepší metody `M` mají stejný počet parametrů jako `D` a převod se považuje za existovat.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-597">Otherwise the algorithm produces a single best method `M` having the same number of parameters as `D` and the conversion is considered to exist.</span></span>
*  <span data-ttu-id="ba1b0-598">Vybrané metody `M` musí být kompatibilní ([delegovat kompatibility](delegates.md#delegate-compatibility)) s typem delegáta `D`, nebo v opačném případě dojde k chybě kompilace.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-598">The selected method `M` must be compatible ([Delegate compatibility](delegates.md#delegate-compatibility)) with the delegate type `D`, or otherwise, a compile-time error occurs.</span></span>
*  <span data-ttu-id="ba1b0-599">Pokud vybrané metody `M` je metoda instance, výraz instance přidružené k `E` Určuje cílový objekt delegáta.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-599">If the selected method `M` is an instance method, the instance expression associated with `E` determines the target object of the delegate.</span></span>
*  <span data-ttu-id="ba1b0-600">Pokud vybrané metody M metodu rozšíření, které je označené prostřednictvím přístupu ke členu na výraz instance, určuje tento výraz instance cílové objektů delegáta.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-600">If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</span></span>
*  <span data-ttu-id="ba1b0-601">Výsledkem převodu je hodnota typu `D`, a to nově vytvořený delegát, který odkazuje na vybrané metody a cílový objekt.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-601">The result of the conversion is a value of type `D`, namely a newly created delegate that refers to the selected method and target object.</span></span>
*  <span data-ttu-id="ba1b0-602">Všimněte si, že tento proces může vést k vytvoření delegáta, kterého lze metodu rozšíření, pokud algoritmus [volání metod](expressions.md#method-invocations) nepodaří najít metodu instance, ale při zpracování volání úspěšné `E(A)` jako rozšíření volání metody ([volání metod rozšíření](expressions.md#extension-method-invocations)).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-602">Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of [Method invocations](expressions.md#method-invocations) fails to find an instance method but succeeds in processing the invocation of `E(A)` as an extension method invocation ([Extension method invocations](expressions.md#extension-method-invocations)).</span></span> <span data-ttu-id="ba1b0-603">Proto vytvoří delegát zaznamená metody rozšíření, stejně jako svůj první argument.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-603">A delegate thus created captures the extension method as well as its first argument.</span></span>

<span data-ttu-id="ba1b0-604">Následující příklad ukazuje metodu skupiny převody:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-604">The following example demonstrates method group conversions:</span></span>
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

<span data-ttu-id="ba1b0-605">Přiřazení `d1` implicitně převede skupinu metod `F` na hodnotu typu `D1`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-605">The assignment to `d1` implicitly converts the method group `F` to a value of type `D1`.</span></span>

<span data-ttu-id="ba1b0-606">Přiřazení `d2` ukazuje, jak je možné k vytvoření delegáta metodě, která má méně odvozené (kontravariantní) typy parametrů a více odvozený návratový typ (kovariantní).</span><span class="sxs-lookup"><span data-stu-id="ba1b0-606">The assignment to `d2` shows how it is possible to create a delegate to a method that has less derived (contravariant) parameter types and a more derived (covariant) return type.</span></span>

<span data-ttu-id="ba1b0-607">Přiřazení `d3` ukazuje, jak neexistuje žádný převod Pokud metoda není použitelné.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-607">The assignment to `d3` shows how no conversion exists if the method is not applicable.</span></span>

<span data-ttu-id="ba1b0-608">Přiřazení `d4` ukazuje, jak metoda musí být použitelné v podobě normální.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-608">The assignment to `d4` shows how the method must be applicable in its normal form.</span></span>

<span data-ttu-id="ba1b0-609">Přiřazení `d5` ukazuje, jak budou moci parametry a návratovým typem delegáta a metoda se liší pouze pro typy odkazů.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-609">The assignment to `d5` shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</span></span>

<span data-ttu-id="ba1b0-610">Stejně jako všechny ostatní implicitní a explicitní převody, operátor přetypování lze explicitně provést převod metody skupiny.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-610">As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion.</span></span> <span data-ttu-id="ba1b0-611">Díky tomu se v příkladu</span><span class="sxs-lookup"><span data-stu-id="ba1b0-611">Thus, the example</span></span>
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
<span data-ttu-id="ba1b0-612">Místo toho může být napsaná</span><span class="sxs-lookup"><span data-stu-id="ba1b0-612">could instead be written</span></span>
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

<span data-ttu-id="ba1b0-613">Metoda skupiny může ovlivnit řešení přetížení a účastnit odvození typu proměnné.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-613">Method groups may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="ba1b0-614">Zobrazit [funkce členy](expressions.md#function-members) další podrobnosti.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-614">See [Function members](expressions.md#function-members) for further details.</span></span>

<span data-ttu-id="ba1b0-615">Hodnocení za běhu metoda převodu skupiny probíhá následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-615">The run-time evaluation of a method group conversion proceeds as follows:</span></span>

*  <span data-ttu-id="ba1b0-616">Pokud metoda vybrané v době kompilace je metoda instance, nebo metodu rozšíření, která je přístupná jako metodu instance, objekt cílového delegáta je určen z instance výraz přidružený k `E`:</span><span class="sxs-lookup"><span data-stu-id="ba1b0-616">If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with `E`:</span></span>
    * <span data-ttu-id="ba1b0-617">Instance výraz je vyhodnocen.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-617">The instance expression is evaluated.</span></span> <span data-ttu-id="ba1b0-618">Je-li toto vyhodnocení způsobí výjimku, jsou spuštěny žádné další kroky.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-618">If this evaluation causes an exception, no further steps are executed.</span></span>
    * <span data-ttu-id="ba1b0-619">Pokud má výraz instance *reference_type*, hodnota vypočítaná aplikací výraz instance stane cílového objektu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-619">If the instance expression is of a *reference_type*, the value computed by the instance expression becomes the target object.</span></span> <span data-ttu-id="ba1b0-620">Pokud je metoda instance vybrané metody a cílový objekt má `null`, `System.NullReferenceException` je vyvolána, a že jsou provedeny žádné další kroky.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-620">If the selected method is an instance method and the target object is `null`, a `System.NullReferenceException` is thrown and no further steps are executed.</span></span>
    * <span data-ttu-id="ba1b0-621">Pokud má výraz instance *value_type*, operace zabalení ([zabalení převody](types.md#boxing-conversions)) se provádí za účelem převodu hodnoty na objekt, a tento objekt se stane cílového objektu.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-621">If the instance expression is of a *value_type*, a boxing operation ([Boxing conversions](types.md#boxing-conversions)) is performed to convert the value to an object, and this object becomes the target object.</span></span>
*  <span data-ttu-id="ba1b0-622">V opačném případě vybrané metody je součástí volání statické metody, a cílový objekt delegáta má `null`.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-622">Otherwise the selected method is part of a static method call, and the target object of the delegate is `null`.</span></span>
*  <span data-ttu-id="ba1b0-623">Nová instance typu delegáta `D` je přidělen.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-623">A new instance of the delegate type `D` is allocated.</span></span> <span data-ttu-id="ba1b0-624">Pokud není k dispozici dostatek paměti k přidělení nové instance `System.OutOfMemoryException` je vyvolána, a že jsou provedeny žádné další kroky.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-624">If there is not enough memory available to allocate the new instance, a `System.OutOfMemoryException` is thrown and no further steps are executed.</span></span>
*  <span data-ttu-id="ba1b0-625">Odkaz na metodu, která byla určena v době kompilace se inicializuje novou instanci delegáta a odkaz k cílovému objektu svého vypočítané výše.</span><span class="sxs-lookup"><span data-stu-id="ba1b0-625">The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</span></span>
