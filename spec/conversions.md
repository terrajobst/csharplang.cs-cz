---
ms.openlocfilehash: 4d6d28a3127bc701867afe157aa5496377a06f69
ms.sourcegitcommit: 63d276488c9770a565fd787020783ffc1d2af9d6
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 12/05/2019
ms.locfileid: "74868001"
---
# <a name="conversions"></a><span data-ttu-id="67b26-101">Převody</span><span class="sxs-lookup"><span data-stu-id="67b26-101">Conversions</span></span>

<span data-ttu-id="67b26-102">***Převod*** umožňuje, aby byl výraz považován za konkrétní typ.</span><span class="sxs-lookup"><span data-stu-id="67b26-102">A ***conversion*** enables an expression to be treated as being of a particular type.</span></span> <span data-ttu-id="67b26-103">Převod může způsobit, že se výraz daného typu bude považovat za jiný typ, nebo může způsobit, že se pro získání typu výraz bez typu.</span><span class="sxs-lookup"><span data-stu-id="67b26-103">A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type.</span></span> <span data-ttu-id="67b26-104">Převody mohou být ***implicitní*** nebo ***explicitní***a tato funkce určuje, zda je vyžadováno explicitní přetypování.</span><span class="sxs-lookup"><span data-stu-id="67b26-104">Conversions can be ***implicit*** or ***explicit***, and this determines whether an explicit cast is required.</span></span> <span data-ttu-id="67b26-105">Například převod z typu `int` na typ `long` je implicitní, takže výrazy typu `int` lze implicitně považovat za typ `long`.</span><span class="sxs-lookup"><span data-stu-id="67b26-105">For instance, the conversion from type `int` to type `long` is implicit, so expressions of type `int` can implicitly be treated as type `long`.</span></span> <span data-ttu-id="67b26-106">Opačný převod, od typu `long` na typ `int`, je explicitní, takže je potřeba explicitní přetypování.</span><span class="sxs-lookup"><span data-stu-id="67b26-106">The opposite conversion, from type `long` to type `int`, is explicit and so an explicit cast is required.</span></span>

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

<span data-ttu-id="67b26-107">Některé převody jsou definovány jazykem.</span><span class="sxs-lookup"><span data-stu-id="67b26-107">Some conversions are defined by the language.</span></span> <span data-ttu-id="67b26-108">Programy mohou také definovat vlastní převody ([uživatelem definované převody](conversions.md#user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="67b26-108">Programs may also define their own conversions ([User-defined conversions](conversions.md#user-defined-conversions)).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="67b26-109">Implicitní převody</span><span class="sxs-lookup"><span data-stu-id="67b26-109">Implicit conversions</span></span>

<span data-ttu-id="67b26-110">Následující převody jsou klasifikovány jako implicitní převody:</span><span class="sxs-lookup"><span data-stu-id="67b26-110">The following conversions are classified as implicit conversions:</span></span>

*  <span data-ttu-id="67b26-111">Převody identity</span><span class="sxs-lookup"><span data-stu-id="67b26-111">Identity conversions</span></span>
*  <span data-ttu-id="67b26-112">Implicitní číselné převody</span><span class="sxs-lookup"><span data-stu-id="67b26-112">Implicit numeric conversions</span></span>
*  <span data-ttu-id="67b26-113">Implicitní převody výčtu</span><span class="sxs-lookup"><span data-stu-id="67b26-113">Implicit enumeration conversions</span></span>
*  <span data-ttu-id="67b26-114">Implicitně interpolované převody řetězců</span><span class="sxs-lookup"><span data-stu-id="67b26-114">Implicit interpolated string conversions</span></span>
*  <span data-ttu-id="67b26-115">Implicitní převody s možnou hodnotou null</span><span class="sxs-lookup"><span data-stu-id="67b26-115">Implicit nullable conversions</span></span>
*  <span data-ttu-id="67b26-116">Nulové převody literálů</span><span class="sxs-lookup"><span data-stu-id="67b26-116">Null literal conversions</span></span>
*  <span data-ttu-id="67b26-117">Implicitní převody odkazů</span><span class="sxs-lookup"><span data-stu-id="67b26-117">Implicit reference conversions</span></span>
*  <span data-ttu-id="67b26-118">Převody zabalení</span><span class="sxs-lookup"><span data-stu-id="67b26-118">Boxing conversions</span></span>
*  <span data-ttu-id="67b26-119">Implicitní dynamické převody</span><span class="sxs-lookup"><span data-stu-id="67b26-119">Implicit dynamic conversions</span></span>
*  <span data-ttu-id="67b26-120">Implicitní převody konstantních výrazů</span><span class="sxs-lookup"><span data-stu-id="67b26-120">Implicit constant expression conversions</span></span>
*  <span data-ttu-id="67b26-121">Uživatelem definované implicitní převody</span><span class="sxs-lookup"><span data-stu-id="67b26-121">User-defined implicit conversions</span></span>
*  <span data-ttu-id="67b26-122">Anonymní převody funkcí</span><span class="sxs-lookup"><span data-stu-id="67b26-122">Anonymous function conversions</span></span>
*  <span data-ttu-id="67b26-123">Převody skupin metod</span><span class="sxs-lookup"><span data-stu-id="67b26-123">Method group conversions</span></span>

<span data-ttu-id="67b26-124">Implicitní převody mohou nastat v různých situacích, včetně vyvolání členů funkce ([Kontrola dynamického přetěžování při kompilaci](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), výrazů přetypování ([výrazů přetypování](expressions.md#cast-expressions)) a přiřazení ([operátory přiřazení](expressions.md#assignment-operators)).</span><span class="sxs-lookup"><span data-stu-id="67b26-124">Implicit conversions can occur in a variety of situations, including function member invocations ([Compile-time checking of dynamic overload resolution](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), and assignments ([Assignment operators](expressions.md#assignment-operators)).</span></span>

<span data-ttu-id="67b26-125">Předem definované implicitní převody jsou vždy úspěšné a nikdy nezpůsobí vyvolání výjimek.</span><span class="sxs-lookup"><span data-stu-id="67b26-125">The pre-defined implicit conversions always succeed and never cause exceptions to be thrown.</span></span> <span data-ttu-id="67b26-126">I správně navržené uživatelem definované implicitní převody by se měly projevit i na těchto vlastnostech.</span><span class="sxs-lookup"><span data-stu-id="67b26-126">Properly designed user-defined implicit conversions should exhibit these characteristics as well.</span></span>

<span data-ttu-id="67b26-127">Pro účely převodu jsou typy `object` a `dynamic` považovány za ekvivalentní.</span><span class="sxs-lookup"><span data-stu-id="67b26-127">For the purposes of conversion, the types `object` and `dynamic` are considered equivalent.</span></span>

<span data-ttu-id="67b26-128">Nicméně dynamické převody ([implicitní dynamické převody](conversions.md#implicit-dynamic-conversions) a [explicitní dynamické převody](conversions.md#explicit-dynamic-conversions)) platí pouze pro výrazy typu `dynamic` ([dynamický typ](types.md#the-dynamic-type)).</span><span class="sxs-lookup"><span data-stu-id="67b26-128">However, dynamic conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)) apply only to expressions of type `dynamic` ([The dynamic type](types.md#the-dynamic-type)).</span></span>

### <a name="identity-conversion"></a><span data-ttu-id="67b26-129">Převod identity</span><span class="sxs-lookup"><span data-stu-id="67b26-129">Identity conversion</span></span>

<span data-ttu-id="67b26-130">Převod identity se převede z libovolného typu na stejný typ.</span><span class="sxs-lookup"><span data-stu-id="67b26-130">An identity conversion converts from any type to the same type.</span></span> <span data-ttu-id="67b26-131">Tento převod existuje tak, aby entita, která už má požadovaný typ, mohla být převoditelné na tento typ.</span><span class="sxs-lookup"><span data-stu-id="67b26-131">This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</span></span>

*  <span data-ttu-id="67b26-132">Vzhledem k tomu, že `object` a `dynamic` jsou považovány za ekvivalentní, existuje převod identity mezi `object` a `dynamic`a mezi konstruovanými typy, které jsou stejné při nahrazování všech výskytů `dynamic` s `object`.</span><span class="sxs-lookup"><span data-stu-id="67b26-132">Because `object` and `dynamic` are considered equivalent there is an identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing all occurrences of `dynamic` with `object`.</span></span>

### <a name="implicit-numeric-conversions"></a><span data-ttu-id="67b26-133">Implicitní číselné převody</span><span class="sxs-lookup"><span data-stu-id="67b26-133">Implicit numeric conversions</span></span>

<span data-ttu-id="67b26-134">Implicitní číselné převody jsou:</span><span class="sxs-lookup"><span data-stu-id="67b26-134">The implicit numeric conversions are:</span></span>

*  <span data-ttu-id="67b26-135">Z `sbyte` na `short`, `int`, `long`, `float`, `double`nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="67b26-135">From `sbyte` to `short`, `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="67b26-136">Z `byte` na `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="67b26-136">From `byte` to `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="67b26-137">Z `short` na `int`, `long`, `float`, `double`nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="67b26-137">From `short` to `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="67b26-138">Z `ushort` na `int`, `uint`, `long`, `ulong`, `float`, `double`nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="67b26-138">From `ushort` to `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="67b26-139">Z `int` `long`, `float`, `double`nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="67b26-139">From `int` to `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="67b26-140">Z `uint` na `long`, `ulong`, `float`, `double`nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="67b26-140">From `uint` to `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="67b26-141">Z `long` `float`, `double`nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="67b26-141">From `long` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="67b26-142">Z `ulong` `float`, `double`nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="67b26-142">From `ulong` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="67b26-143">Z `char` na `ushort`, `int``uint`, `long`, `ulong`, `float`, `double`nebo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="67b26-143">From `char` to `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="67b26-144">Z `float` `double`.</span><span class="sxs-lookup"><span data-stu-id="67b26-144">From `float` to `double`.</span></span>

<span data-ttu-id="67b26-145">Převody z `int`, `uint`, `long`nebo `ulong` na `float` a z `long` nebo `ulong` na `double` mohou způsobit ztrátu přesnosti, ale nikdy nezpůsobí ztrátu velikosti.</span><span class="sxs-lookup"><span data-stu-id="67b26-145">Conversions from `int`, `uint`, `long`, or `ulong` to `float` and from `long` or `ulong` to `double` may cause a loss of precision, but will never cause a loss of magnitude.</span></span> <span data-ttu-id="67b26-146">Ostatní implicitní číselné převody nikdy neztratí žádné informace.</span><span class="sxs-lookup"><span data-stu-id="67b26-146">The other implicit numeric conversions never lose any information.</span></span>

<span data-ttu-id="67b26-147">Neexistují žádné implicitní převody na typ `char`, takže hodnoty ostatních integrálních typů nejsou automaticky převedeny na typ `char`.</span><span class="sxs-lookup"><span data-stu-id="67b26-147">There are no implicit conversions to the `char` type, so values of the other integral types do not automatically convert to the `char` type.</span></span>

### <a name="implicit-enumeration-conversions"></a><span data-ttu-id="67b26-148">Implicitní převody výčtu</span><span class="sxs-lookup"><span data-stu-id="67b26-148">Implicit enumeration conversions</span></span>

<span data-ttu-id="67b26-149">Implicitní převod výčtu umožňuje *decimal_integer_literal* `0` převést na jakýkoli *enum_type* a na všechny *nullable_type* jejichž základní typ je *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="67b26-149">An implicit enumeration conversion permits the *decimal_integer_literal* `0` to be converted to any *enum_type* and to any *nullable_type* whose underlying type is an *enum_type*.</span></span> <span data-ttu-id="67b26-150">V druhém případě je převod vyhodnocen převodem na podkladovou *enum_type* a zabalením výsledku ([typy s možnou hodnotou null](types.md#nullable-types)).</span><span class="sxs-lookup"><span data-stu-id="67b26-150">In the latter case the conversion is evaluated by converting to the underlying *enum_type* and wrapping the result ([Nullable types](types.md#nullable-types)).</span></span>

### <a name="implicit-interpolated-string-conversions"></a><span data-ttu-id="67b26-151">Implicitně interpolované převody řetězců</span><span class="sxs-lookup"><span data-stu-id="67b26-151">Implicit interpolated string conversions</span></span>

<span data-ttu-id="67b26-152">Implicitně interpolovaná konverze řetězce umožňuje převést *interpolated_string_expression* ([interpolované řetězce](expressions.md#interpolated-strings)) na `System.IFormattable` nebo `System.FormattableString` (což implementuje `System.IFormattable`).</span><span class="sxs-lookup"><span data-stu-id="67b26-152">An implicit interpolated string conversion permits an *interpolated_string_expression* ([Interpolated strings](expressions.md#interpolated-strings)) to be converted to `System.IFormattable` or `System.FormattableString` (which implements `System.IFormattable`).</span></span>

<span data-ttu-id="67b26-153">Při použití tohoto převodu se hodnota řetězce neskládá z interpolované řetězce.</span><span class="sxs-lookup"><span data-stu-id="67b26-153">When this conversion is applied a string value is not composed from the interpolated string.</span></span> <span data-ttu-id="67b26-154">Namísto toho je vytvořena instance `System.FormattableString`, jak je popsáno dále v [interpolovaná řetězce](expressions.md#interpolated-strings).</span><span class="sxs-lookup"><span data-stu-id="67b26-154">Instead an instance of `System.FormattableString` is created, as further described in [Interpolated strings](expressions.md#interpolated-strings).</span></span>

### <a name="implicit-nullable-conversions"></a><span data-ttu-id="67b26-155">Implicitní převody s možnou hodnotou null</span><span class="sxs-lookup"><span data-stu-id="67b26-155">Implicit nullable conversions</span></span>

<span data-ttu-id="67b26-156">Předdefinované implicitní převody, které pracují s typy hodnot, které neumožňují hodnotu null, lze také použít s připouštějící formuláře těchto typů.</span><span class="sxs-lookup"><span data-stu-id="67b26-156">Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types.</span></span> <span data-ttu-id="67b26-157">Pro každé z předdefinovaných implicitních a numerických převodů, které se převádějí z typu hodnoty, která není null, `S` na `T`typu hodnot, který neumožňuje hodnotu null, existují následující implicitní převody s možnou hodnotou null:</span><span class="sxs-lookup"><span data-stu-id="67b26-157">For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type `S` to a non-nullable value type `T`, the following implicit nullable conversions exist:</span></span>

*  <span data-ttu-id="67b26-158">Implicitní převod z `S?` na `T?`.</span><span class="sxs-lookup"><span data-stu-id="67b26-158">An implicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="67b26-159">Implicitní převod z `S` na `T?`.</span><span class="sxs-lookup"><span data-stu-id="67b26-159">An implicit conversion from `S` to `T?`.</span></span>

<span data-ttu-id="67b26-160">Vyhodnocení implicitního převodu s možnou hodnotou null na základě základní konverze z `S` na `T` pokračuje následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="67b26-160">Evaluation of an implicit nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="67b26-161">Pokud je převod s možnou hodnotou null z `S?` na `T?`:</span><span class="sxs-lookup"><span data-stu-id="67b26-161">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="67b26-162">Pokud má zdrojová hodnota hodnotu null (`HasValue` vlastnost je false), výsledkem je hodnota null typu `T?`.</span><span class="sxs-lookup"><span data-stu-id="67b26-162">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="67b26-163">V opačném případě je převod vyhodnocen jako rozbalení z `S?` na `S`a za ním následuje základní převod z `S` na `T`a za který následuje obtékání ([typy s možnou hodnotou null](types.md#nullable-types)) z `T` na `T?`.</span><span class="sxs-lookup"><span data-stu-id="67b26-163">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping ([Nullable types](types.md#nullable-types)) from `T` to `T?`.</span></span>

*  <span data-ttu-id="67b26-164">Pokud je převod s možnou hodnotou null z `S` na `T?`, převod se vyhodnotí jako základní převod z `S` na `T` následovaný zalomením z `T` na `T?`.</span><span class="sxs-lookup"><span data-stu-id="67b26-164">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>

### <a name="null-literal-conversions"></a><span data-ttu-id="67b26-165">Nulové převody literálů</span><span class="sxs-lookup"><span data-stu-id="67b26-165">Null literal conversions</span></span>

<span data-ttu-id="67b26-166">Implicitní převod existuje z `null` literálu na libovolný typ s možnou hodnotou null.</span><span class="sxs-lookup"><span data-stu-id="67b26-166">An implicit conversion exists from the `null` literal to any nullable type.</span></span> <span data-ttu-id="67b26-167">Tento převod vytvoří hodnotu null ([typy s možnou hodnotou](types.md#nullable-types)null) daného typu s možnou hodnotou null.</span><span class="sxs-lookup"><span data-stu-id="67b26-167">This conversion produces the null value ([Nullable types](types.md#nullable-types)) of the given nullable type.</span></span>

### <a name="implicit-reference-conversions"></a><span data-ttu-id="67b26-168">Implicitní převody odkazů</span><span class="sxs-lookup"><span data-stu-id="67b26-168">Implicit reference conversions</span></span>

<span data-ttu-id="67b26-169">Implicitní převody odkazů:</span><span class="sxs-lookup"><span data-stu-id="67b26-169">The implicit reference conversions are:</span></span>

*  <span data-ttu-id="67b26-170">Z libovolného *reference_type* na `object` a `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="67b26-170">From any *reference_type* to `object` and `dynamic`.</span></span>
*  <span data-ttu-id="67b26-171">Z jakéhokoli *class_type* `S` na všechny *class_type* `T`je zadaný `S` odvozený od `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-171">From any *class_type* `S` to any *class_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="67b26-172">Z jakéhokoli *class_type* `S` na všechny *interface_type* `T`zadané `S` implementuje `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-172">From any *class_type* `S` to any *interface_type* `T`, provided `S` implements `T`.</span></span>
*  <span data-ttu-id="67b26-173">Z jakéhokoli *interface_type* `S` na všechny *INTERFACE_TYPE* `T`je zadaný `S` odvozený od `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-173">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="67b26-174">Z *array_type* `S` s typem elementu `SE` do *array_type* `T` s typem prvku `TE`, za předpokladu, že jsou splněny všechny následující podmínky:</span><span class="sxs-lookup"><span data-stu-id="67b26-174">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="67b26-175">`S` a `T` se liší pouze v typu prvku.</span><span class="sxs-lookup"><span data-stu-id="67b26-175">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="67b26-176">Jinými slovy, `S` a `T` mají stejný počet rozměrů.</span><span class="sxs-lookup"><span data-stu-id="67b26-176">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="67b26-177">`SE` i `TE` jsou *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="67b26-177">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="67b26-178">Implicitní převod odkazu existuje z `SE` na `TE`.</span><span class="sxs-lookup"><span data-stu-id="67b26-178">An implicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="67b26-179">Z jakéhokoli *array_type* `System.Array` a rozhraní, které implementuje.</span><span class="sxs-lookup"><span data-stu-id="67b26-179">From any *array_type* to `System.Array` and the interfaces it implements.</span></span>
*  <span data-ttu-id="67b26-180">Z jednorozměrného typu pole `S[]` `System.Collections.Generic.IList<T>` a jeho základních rozhraní za předpokladu, že existuje implicitní identita nebo převod odkazu z `S` na `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-180">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an implicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="67b26-181">Z jakéhokoli *delegate_type* `System.Delegate` a rozhraní, které implementuje.</span><span class="sxs-lookup"><span data-stu-id="67b26-181">From any *delegate_type* to `System.Delegate` and the interfaces it implements.</span></span>
*  <span data-ttu-id="67b26-182">Z nulového literálu na libovolný *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="67b26-182">From the null literal to any *reference_type*.</span></span>
*  <span data-ttu-id="67b26-183">Z libovolného *reference_type* na *reference_type* `T`, pokud má implicitní identitu nebo převod referencí na *reference_type* `T0` a `T0` má převod identity na `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-183">From any *reference_type* to a *reference_type* `T` if it has an implicit identity or reference conversion to a *reference_type* `T0` and `T0` has an identity conversion to `T`.</span></span>
*  <span data-ttu-id="67b26-184">Z libovolného *reference_type* na typ rozhraní nebo delegáta `T`, pokud má implicitní identitu nebo převod odkazu na typ rozhraní nebo delegáta `T0` a `T0` je variance-konvertibilní ([Převod variance](interfaces.md#variance-conversion)) na `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-184">From any *reference_type* to an interface or delegate type `T` if it has an implicit identity or reference conversion to an interface or delegate type `T0` and `T0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `T`.</span></span>
*  <span data-ttu-id="67b26-185">Implicitní převody zahrnující parametry typu, které jsou označovány jako odkazové typy.</span><span class="sxs-lookup"><span data-stu-id="67b26-185">Implicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="67b26-186">Další podrobnosti o implicitních převodech týkajících se parametrů typu naleznete v tématu [implicitní převody zahrnující parametry typu](conversions.md#implicit-conversions-involving-type-parameters) .</span><span class="sxs-lookup"><span data-stu-id="67b26-186">See [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) for more details on implicit conversions involving type parameters.</span></span>

<span data-ttu-id="67b26-187">Implicitní převody odkazů jsou tyto převody mezi *reference_type*s, které mohou být prověřeny tak, aby byly vždy úspěšné, a proto nevyžadují žádné kontroly za běhu.</span><span class="sxs-lookup"><span data-stu-id="67b26-187">The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</span></span>

<span data-ttu-id="67b26-188">Převody odkazů, implicitní nebo explicitní, nikdy nezmění referenční identitu převáděného objektu.</span><span class="sxs-lookup"><span data-stu-id="67b26-188">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="67b26-189">Jinými slovy, zatímco převod odkazu může změnit typ odkazu, nikdy nemění typ nebo hodnotu objektu, na který je odkazováno.</span><span class="sxs-lookup"><span data-stu-id="67b26-189">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="67b26-190">Převody zabalení</span><span class="sxs-lookup"><span data-stu-id="67b26-190">Boxing conversions</span></span>

<span data-ttu-id="67b26-191">Převod zabalení umožňuje *value_type* implicitně převést na typ odkazu.</span><span class="sxs-lookup"><span data-stu-id="67b26-191">A boxing conversion permits a *value_type* to be implicitly converted to a reference type.</span></span> <span data-ttu-id="67b26-192">Převod zabalení existuje z libovolného *non_nullable_value_type* na `object` a `dynamic`, na `System.ValueType` a na všechny *INTERFACE_TYPE* implementované *non_nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="67b26-192">A boxing conversion exists from any *non_nullable_value_type* to `object` and `dynamic`, to `System.ValueType` and to any *interface_type* implemented by the *non_nullable_value_type*.</span></span> <span data-ttu-id="67b26-193">Kromě toho je možné *enum_type* převést na typ `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="67b26-193">Furthermore an *enum_type* can be converted to the type `System.Enum`.</span></span>

<span data-ttu-id="67b26-194">Převod zabalení existuje z *nullable_type* na odkazový typ, pokud a pouze v případě, že v podkladovém *non_nullable_value_type* existuje převod zabalení na odkazový typ.</span><span class="sxs-lookup"><span data-stu-id="67b26-194">A boxing conversion exists from a *nullable_type* to a reference type, if and only if a boxing conversion exists from the underlying *non_nullable_value_type* to the reference type.</span></span>

<span data-ttu-id="67b26-195">Typ hodnoty má převod zabalení na typ rozhraní `I`, pokud obsahuje převod zabalení na typ rozhraní `I0` a `I0` má převod identity na `I`.</span><span class="sxs-lookup"><span data-stu-id="67b26-195">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="67b26-196">Typ hodnoty má převod zabalení na typ rozhraní `I`, pokud má převod zabalení na typ rozhraní nebo delegáta `I0` a `I0` je převoditelné Variance ([Převod variance](interfaces.md#variance-conversion)) na `I`.</span><span class="sxs-lookup"><span data-stu-id="67b26-196">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface or delegate type `I0` and `I0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `I`.</span></span>

<span data-ttu-id="67b26-197">Zabalení hodnoty *non_nullable_value_type* se skládá z přidělení instance objektu a zkopírování *value_type* hodnoty do této instance.</span><span class="sxs-lookup"><span data-stu-id="67b26-197">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *value_type* value into that instance.</span></span> <span data-ttu-id="67b26-198">Struktura může být zabalená do typu `System.ValueType`, protože se jedná o základní třídu pro všechny struktury ([Dědičnost](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="67b26-198">A struct can be boxed to the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="67b26-199">Zabalení hodnoty *nullable_type* pokračuje následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="67b26-199">Boxing a value of a *nullable_type* proceeds as follows:</span></span>

*  <span data-ttu-id="67b26-200">Pokud má zdrojová hodnota hodnotu null (`HasValue` vlastnost je false), výsledek je odkaz s hodnotou null cílového typu.</span><span class="sxs-lookup"><span data-stu-id="67b26-200">If the source value is null (`HasValue` property is false), the result is a null reference of the target type.</span></span>
*  <span data-ttu-id="67b26-201">V opačném případě je výsledkem odkaz na zabalenou `T` vytvořenou rozbalením a zabalením zdrojové hodnoty.</span><span class="sxs-lookup"><span data-stu-id="67b26-201">Otherwise, the result is a reference to a boxed `T` produced by unwrapping and boxing the source value.</span></span>

<span data-ttu-id="67b26-202">Převody zabalení jsou podrobněji popsány v tématu [převody zabalení](types.md#boxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="67b26-202">Boxing conversions are described further in [Boxing conversions](types.md#boxing-conversions).</span></span>

### <a name="implicit-dynamic-conversions"></a><span data-ttu-id="67b26-203">Implicitní dynamické převody</span><span class="sxs-lookup"><span data-stu-id="67b26-203">Implicit dynamic conversions</span></span>

<span data-ttu-id="67b26-204">Implicitní dynamický převod existuje ve výrazu typu `dynamic` na libovolný typ `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-204">An implicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="67b26-205">Převod je dynamicky svázán ([dynamická vazba](expressions.md#dynamic-binding)), což znamená, že implicitní převod bude vyžádán za běhu z běhového typu výrazu do `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-205">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="67b26-206">Pokud není nalezen žádný převod, je vyvolána výjimka za běhu.</span><span class="sxs-lookup"><span data-stu-id="67b26-206">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="67b26-207">Všimněte si, že tento implicitní převod zdánlivě porušuje Rady na začátku [implicitních převodů](conversions.md#implicit-conversions) , že implicitní převod by nikdy neměl způsobovat výjimku.</span><span class="sxs-lookup"><span data-stu-id="67b26-207">Note that this implicit conversion seemingly violates the advice in the beginning of [Implicit conversions](conversions.md#implicit-conversions) that an implicit conversion should never cause an exception.</span></span> <span data-ttu-id="67b26-208">Nejedná se však o samotný převod, ale *hledání* převodu, který způsobuje výjimku.</span><span class="sxs-lookup"><span data-stu-id="67b26-208">However it is not the conversion itself, but the *finding* of the conversion that causes the exception.</span></span> <span data-ttu-id="67b26-209">Riziko běhových výjimek je podstatou použití dynamické vazby.</span><span class="sxs-lookup"><span data-stu-id="67b26-209">The risk of run-time exceptions is inherent in the use of dynamic binding.</span></span> <span data-ttu-id="67b26-210">Pokud dynamická vazba převodu není žádoucí, výraz může být nejprve převeden na `object`a následně na požadovaný typ.</span><span class="sxs-lookup"><span data-stu-id="67b26-210">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="67b26-211">Následující příklad ilustruje implicitní dynamické převody:</span><span class="sxs-lookup"><span data-stu-id="67b26-211">The following example illustrates implicit dynamic conversions:</span></span>

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

<span data-ttu-id="67b26-212">Přiřazení pro `s2` a `i` používají implicitní dynamické převody, kde je vazba operací pozastavena až do doby běhu.</span><span class="sxs-lookup"><span data-stu-id="67b26-212">The assignments to `s2` and `i` both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time.</span></span> <span data-ttu-id="67b26-213">V době běhu jsou implicitní převody požadovány z běhového typu `d` -- `string`--do cílového typu.</span><span class="sxs-lookup"><span data-stu-id="67b26-213">At run-time, implicit conversions are sought from the run-time type of `d` -- `string` -- to the target type.</span></span> <span data-ttu-id="67b26-214">Byl nalezen převod pro `string`, ale ne pro `int`.</span><span class="sxs-lookup"><span data-stu-id="67b26-214">A conversion is found to `string` but not to `int`.</span></span>

### <a name="implicit-constant-expression-conversions"></a><span data-ttu-id="67b26-215">Implicitní převody konstantních výrazů</span><span class="sxs-lookup"><span data-stu-id="67b26-215">Implicit constant expression conversions</span></span>

<span data-ttu-id="67b26-216">Implicitní převod konstantního výrazu povoluje následující převody:</span><span class="sxs-lookup"><span data-stu-id="67b26-216">An implicit constant expression conversion permits the following conversions:</span></span>

*  <span data-ttu-id="67b26-217">*Constant_expression* ([konstantní výrazy](expressions.md#constant-expressions)) typu `int` lze převést na typ `sbyte`, `byte`, `short`, `ushort`, `uint`nebo `ulong`, pokud je hodnota *constant_expression* v rozsahu cílového typu.</span><span class="sxs-lookup"><span data-stu-id="67b26-217">A *constant_expression* ([Constant expressions](expressions.md#constant-expressions)) of type `int` can be converted to type `sbyte`, `byte`, `short`, `ushort`, `uint`, or `ulong`, provided the value of the *constant_expression* is within the range of the destination type.</span></span>
*  <span data-ttu-id="67b26-218">*Constant_expression* typu `long` lze převést na typ `ulong`za předpokladu, že hodnota *constant_expression* není záporná.</span><span class="sxs-lookup"><span data-stu-id="67b26-218">A *constant_expression* of type `long` can be converted to type `ulong`, provided the value of the *constant_expression* is not negative.</span></span>

### <a name="implicit-conversions-involving-type-parameters"></a><span data-ttu-id="67b26-219">Implicitní převody zahrnující parametry typu</span><span class="sxs-lookup"><span data-stu-id="67b26-219">Implicit conversions involving type parameters</span></span>

<span data-ttu-id="67b26-220">Pro daný parametr typu existují následující implicitní převody `T`:</span><span class="sxs-lookup"><span data-stu-id="67b26-220">The following implicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="67b26-221">Z `T` na jeho efektivní základní třídu `C`, od `T` k jakékoli základní třídě `C`a od `T` k jakémukoli rozhraní implementovanému `C`.</span><span class="sxs-lookup"><span data-stu-id="67b26-221">From `T` to its effective base class `C`, from `T` to any base class of `C`, and from `T` to any interface implemented by `C`.</span></span> <span data-ttu-id="67b26-222">V době běhu, pokud je `T` typ hodnoty, je převod proveden jako převod zabalení.</span><span class="sxs-lookup"><span data-stu-id="67b26-222">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="67b26-223">V opačném případě je převod proveden jako implicitní převod odkazu nebo převod identity.</span><span class="sxs-lookup"><span data-stu-id="67b26-223">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="67b26-224">Z `T` na typ rozhraní `I` v efektivní sadě rozhraní `T`a ze `T` na jakékoli základní rozhraní `I`.</span><span class="sxs-lookup"><span data-stu-id="67b26-224">From `T` to an interface type `I` in `T`'s effective interface set and from `T` to any base interface of `I`.</span></span> <span data-ttu-id="67b26-225">V době běhu, pokud je `T` typ hodnoty, je převod proveden jako převod zabalení.</span><span class="sxs-lookup"><span data-stu-id="67b26-225">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="67b26-226">V opačném případě je převod proveden jako implicitní převod odkazu nebo převod identity.</span><span class="sxs-lookup"><span data-stu-id="67b26-226">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="67b26-227">Z `T` na parametr typu `U`zadaný `T` závisí na `U` ([omezení parametrů typu](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="67b26-227">From `T` to a type parameter `U`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="67b26-228">V době běhu, pokud je `U` typ hodnoty, pak `T` a `U` jsou nutně stejného typu a není proveden žádný převod.</span><span class="sxs-lookup"><span data-stu-id="67b26-228">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="67b26-229">V opačném případě, pokud je `T` typ hodnoty, je převod proveden jako převod zabalení.</span><span class="sxs-lookup"><span data-stu-id="67b26-229">Otherwise, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="67b26-230">V opačném případě je převod proveden jako implicitní převod odkazu nebo převod identity.</span><span class="sxs-lookup"><span data-stu-id="67b26-230">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="67b26-231">Z literálu s hodnotou null na `T`je zadaný `T` známý jako odkazový typ.</span><span class="sxs-lookup"><span data-stu-id="67b26-231">From the null literal to `T`, provided `T` is known to be a reference type.</span></span>
*  <span data-ttu-id="67b26-232">Z `T` na odkazový typ `I`, pokud má implicitní převod na typ odkazu `S0` a `S0` má převod identity na `S`.</span><span class="sxs-lookup"><span data-stu-id="67b26-232">From `T` to a reference type `I` if it has an implicit conversion to a reference type `S0` and `S0` has an identity conversion to `S`.</span></span> <span data-ttu-id="67b26-233">V době běhu je převod proveden stejným způsobem jako převod na `S0`.</span><span class="sxs-lookup"><span data-stu-id="67b26-233">At run-time the conversion is executed the same way as the conversion to `S0`.</span></span>
*  <span data-ttu-id="67b26-234">Z `T` na typ rozhraní `I`, pokud má implicitní převod na rozhraní nebo typ delegáta `I0` a `I0` je variance-konvertibilní na `I` ([Převod variance](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="67b26-234">From `T` to an interface type `I` if it has an implicit conversion to an interface or delegate type `I0` and `I0` is variance-convertible to `I` ([Variance conversion](interfaces.md#variance-conversion)).</span></span> <span data-ttu-id="67b26-235">V době běhu, pokud je `T` typ hodnoty, je převod proveden jako převod zabalení.</span><span class="sxs-lookup"><span data-stu-id="67b26-235">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="67b26-236">V opačném případě je převod proveden jako implicitní převod odkazu nebo převod identity.</span><span class="sxs-lookup"><span data-stu-id="67b26-236">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="67b26-237">Pokud je známo, že je `T` odkazový typ ([omezení parametru typu](classes.md#type-parameter-constraints)), jsou všechny převody klasifikované jako implicitní převody odkazů ([implicitní převody odkazů](conversions.md#implicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="67b26-237">If `T` is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)), the conversions above are all classified as implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions)).</span></span> <span data-ttu-id="67b26-238">Pokud `T` není známý jako typ odkazu, převody uvedené výše jsou klasifikovány jako převody zabalení ([převody zabalení](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="67b26-238">If `T` is not known to be a reference type, the conversions above are classified as boxing conversions ([Boxing conversions](conversions.md#boxing-conversions)).</span></span>

### <a name="user-defined-implicit-conversions"></a><span data-ttu-id="67b26-239">Uživatelem definované implicitní převody</span><span class="sxs-lookup"><span data-stu-id="67b26-239">User-defined implicit conversions</span></span>

<span data-ttu-id="67b26-240">Uživatelem definovaný implicitní převod se skládá z volitelného standardního implicitního převodu, za nímž následuje spuštění uživatelsky definované implicitního operátoru převodu následovaný jiným volitelným standardním implicitním převodem.</span><span class="sxs-lookup"><span data-stu-id="67b26-240">A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion.</span></span> <span data-ttu-id="67b26-241">Přesná pravidla pro vyhodnocení uživatelem definovaných implicitních převodů jsou popsány ve [zpracování uživatelem definovaných implicitních převodů](conversions.md#processing-of-user-defined-implicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="67b26-241">The exact rules for evaluating user-defined implicit conversions are described in [Processing of user-defined implicit conversions](conversions.md#processing-of-user-defined-implicit-conversions).</span></span>

### <a name="anonymous-function-conversions-and-method-group-conversions"></a><span data-ttu-id="67b26-242">Anonymní převody funkcí a převody skupin metod</span><span class="sxs-lookup"><span data-stu-id="67b26-242">Anonymous function conversions and method group conversions</span></span>

<span data-ttu-id="67b26-243">Anonymní funkce a skupiny metod nemají typy v a samotném, ale mohou být implicitně převedeny na typy delegátů nebo strom výrazů.</span><span class="sxs-lookup"><span data-stu-id="67b26-243">Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types.</span></span> <span data-ttu-id="67b26-244">Anonymní převody funkcí jsou podrobněji popsány v tématu [anonymní převody funkcí](conversions.md#anonymous-function-conversions) a převody skupin metod v tématu [převody skupin metod](conversions.md#method-group-conversions).</span><span class="sxs-lookup"><span data-stu-id="67b26-244">Anonymous function conversions are described in more detail in [Anonymous function conversions](conversions.md#anonymous-function-conversions) and method group conversions in [Method group conversions](conversions.md#method-group-conversions).</span></span>

## <a name="explicit-conversions"></a><span data-ttu-id="67b26-245">Explicitní převody</span><span class="sxs-lookup"><span data-stu-id="67b26-245">Explicit conversions</span></span>

<span data-ttu-id="67b26-246">Následující převody jsou klasifikovány jako explicitní převody:</span><span class="sxs-lookup"><span data-stu-id="67b26-246">The following conversions are classified as explicit conversions:</span></span>

*  <span data-ttu-id="67b26-247">Všechny implicitní převody.</span><span class="sxs-lookup"><span data-stu-id="67b26-247">All implicit conversions.</span></span>
*  <span data-ttu-id="67b26-248">Explicitní číselné převody.</span><span class="sxs-lookup"><span data-stu-id="67b26-248">Explicit numeric conversions.</span></span>
*  <span data-ttu-id="67b26-249">Explicitní převody výčtu.</span><span class="sxs-lookup"><span data-stu-id="67b26-249">Explicit enumeration conversions.</span></span>
*  <span data-ttu-id="67b26-250">Explicitní převody s možnou hodnotou null.</span><span class="sxs-lookup"><span data-stu-id="67b26-250">Explicit nullable conversions.</span></span>
*  <span data-ttu-id="67b26-251">Explicitní převody odkazů</span><span class="sxs-lookup"><span data-stu-id="67b26-251">Explicit reference conversions.</span></span>
*  <span data-ttu-id="67b26-252">Explicitní převody rozhraní.</span><span class="sxs-lookup"><span data-stu-id="67b26-252">Explicit interface conversions.</span></span>
*  <span data-ttu-id="67b26-253">Převody rozbalení.</span><span class="sxs-lookup"><span data-stu-id="67b26-253">Unboxing conversions.</span></span>
*  <span data-ttu-id="67b26-254">Explicitní dynamické převody</span><span class="sxs-lookup"><span data-stu-id="67b26-254">Explicit dynamic conversions</span></span>
*  <span data-ttu-id="67b26-255">Uživatelem definované explicitní převody.</span><span class="sxs-lookup"><span data-stu-id="67b26-255">User-defined explicit conversions.</span></span>

<span data-ttu-id="67b26-256">Explicitní převody mohou nastat ve výrazech přetypování ([výrazy přetypování](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="67b26-256">Explicit conversions can occur in cast expressions ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="67b26-257">Sada explicitních převodů zahrnuje všechny implicitní převody.</span><span class="sxs-lookup"><span data-stu-id="67b26-257">The set of explicit conversions includes all implicit conversions.</span></span> <span data-ttu-id="67b26-258">To znamená, že jsou povoleny nadbytečné výrazy přetypování.</span><span class="sxs-lookup"><span data-stu-id="67b26-258">This means that redundant cast expressions are allowed.</span></span>

<span data-ttu-id="67b26-259">Explicitní převody, které nejsou implicitními převody, jsou převody, které nemohou být prověřeny tak, aby byly vždy úspěšné, převody, které mohou ztratit informace, a převody mezi doménami typů, které jsou dostatečně rozdílné jako explicitní. zápis.</span><span class="sxs-lookup"><span data-stu-id="67b26-259">The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</span></span>

### <a name="explicit-numeric-conversions"></a><span data-ttu-id="67b26-260">Explicitní číselné převody</span><span class="sxs-lookup"><span data-stu-id="67b26-260">Explicit numeric conversions</span></span>

<span data-ttu-id="67b26-261">Explicitní číselné převody jsou převody z *numeric_type* na jiný *numeric_type* , pro které implicitní číselný převod ([implicitní číselné převody](conversions.md#implicit-numeric-conversions)) ještě neexistuje:</span><span class="sxs-lookup"><span data-stu-id="67b26-261">The explicit numeric conversions are the conversions from a *numeric_type* to another *numeric_type* for which an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) does not already exist:</span></span>

*  <span data-ttu-id="67b26-262">Z `sbyte` na `byte`, `ushort`, `uint`, `ulong`nebo `char`.</span><span class="sxs-lookup"><span data-stu-id="67b26-262">From `sbyte` to `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="67b26-263">Z `byte` `sbyte` a `char`.</span><span class="sxs-lookup"><span data-stu-id="67b26-263">From `byte` to `sbyte` and `char`.</span></span>
*  <span data-ttu-id="67b26-264">Z `short` na `sbyte`, `byte`, `ushort`, `uint`, `ulong`nebo `char`.</span><span class="sxs-lookup"><span data-stu-id="67b26-264">From `short` to `sbyte`, `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="67b26-265">Z `ushort` `sbyte`, `byte`, `short`nebo `char`.</span><span class="sxs-lookup"><span data-stu-id="67b26-265">From `ushort` to `sbyte`, `byte`, `short`, or `char`.</span></span>
*  <span data-ttu-id="67b26-266">Z `int` na `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`nebo `char`.</span><span class="sxs-lookup"><span data-stu-id="67b26-266">From `int` to `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="67b26-267">Z `uint` na `sbyte`, `byte`, `short`, `ushort`, `int`nebo `char`.</span><span class="sxs-lookup"><span data-stu-id="67b26-267">From `uint` to `sbyte`, `byte`, `short`, `ushort`, `int`, or `char`.</span></span>
*  <span data-ttu-id="67b26-268">Z `long` na `sbyte`, `byte``short`, `ushort`, `int`, `uint`, `ulong`nebo `char`.</span><span class="sxs-lookup"><span data-stu-id="67b26-268">From `long` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="67b26-269">Z `ulong` na `sbyte`, `byte``short`, `ushort`, `int`, `uint`, `long`nebo `char`.</span><span class="sxs-lookup"><span data-stu-id="67b26-269">From `ulong` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, or `char`.</span></span>
*  <span data-ttu-id="67b26-270">Z `char` `sbyte`, `byte`nebo `short`.</span><span class="sxs-lookup"><span data-stu-id="67b26-270">From `char` to `sbyte`, `byte`, or `short`.</span></span>
*  <span data-ttu-id="67b26-271">Z `float` na `sbyte`, `byte``short`, `ushort``int``uint`, `long`, `ulong`, `char`, `decimal`nebo.</span><span class="sxs-lookup"><span data-stu-id="67b26-271">From `float` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, or `decimal`.</span></span>
*  <span data-ttu-id="67b26-272">Z `double` `sbyte`, `byte``short`, `ushort``int``uint`, `long`, `ulong`, `char`, `float`, `decimal`nebo.</span><span class="sxs-lookup"><span data-stu-id="67b26-272">From `double` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `decimal`.</span></span>
*  <span data-ttu-id="67b26-273">Z `decimal` `sbyte`, `byte``short`, `ushort``int``uint`, `long`, `ulong`, `char`, `float`, `double`nebo.</span><span class="sxs-lookup"><span data-stu-id="67b26-273">From `decimal` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `double`.</span></span>

<span data-ttu-id="67b26-274">Vzhledem k tomu, že explicitní převody zahrnují všechny implicitní a explicitní číselné převody, je vždy možné převést z libovolného *numeric_type* na jakékoli jiné *numeric_type* pomocí výrazu přetypování ([výrazy přetypování](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="67b26-274">Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any *numeric_type* to any other *numeric_type* using a cast expression ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="67b26-275">Explicitní číselné převody pravděpodobně ztratí informace nebo mohou způsobit vyvolání výjimek.</span><span class="sxs-lookup"><span data-stu-id="67b26-275">The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown.</span></span> <span data-ttu-id="67b26-276">Explicitní číselný převod je zpracován následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="67b26-276">An explicit numeric conversion is processed as follows:</span></span>

*  <span data-ttu-id="67b26-277">Pro převod z celočíselného typu na jiný integrálový typ zpracování závisí na kontextu kontroly přetečení ([kontrolované a nezaškrtnuté operátory](expressions.md#the-checked-and-unchecked-operators)), ve kterých se převod provádí:</span><span class="sxs-lookup"><span data-stu-id="67b26-277">For a conversion from an integral type to another integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="67b26-278">V kontextu `checked` je převod úspěšný, pokud hodnota zdrojového operandu spadá do rozsahu cílového typu, ale vyvolá `System.OverflowException`, pokud je hodnota zdrojového operandu mimo rozsah cílového typu.</span><span class="sxs-lookup"><span data-stu-id="67b26-278">In a `checked` context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a `System.OverflowException` if the value of the source operand is outside the range of the destination type.</span></span>
    * <span data-ttu-id="67b26-279">V kontextu `unchecked` je převod vždy úspěšný a pokračuje následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="67b26-279">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="67b26-280">Pokud je typ zdroje větší než cílový typ, je zdrojová hodnota zkrácena tím, že zahodí "extra" nejvýznamnější bity.</span><span class="sxs-lookup"><span data-stu-id="67b26-280">If the source type is larger than the destination type, then the source value is truncated by discarding its "extra" most significant bits.</span></span> <span data-ttu-id="67b26-281">Výsledek je pak zpracován jako hodnota cílového typu.</span><span class="sxs-lookup"><span data-stu-id="67b26-281">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="67b26-282">Pokud je typ zdroje menší než cílový typ, pak je zdrojová hodnota buď znaménko, nebo nula – rozšířená, aby měla stejnou velikost jako cílový typ.</span><span class="sxs-lookup"><span data-stu-id="67b26-282">If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type.</span></span> <span data-ttu-id="67b26-283">Podpisové rozšíření se používá, pokud je typ zdroje podepsaný; Pokud je zdrojový typ bez znaménka, je použita nulová přípona.</span><span class="sxs-lookup"><span data-stu-id="67b26-283">Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned.</span></span> <span data-ttu-id="67b26-284">Výsledek je pak zpracován jako hodnota cílového typu.</span><span class="sxs-lookup"><span data-stu-id="67b26-284">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="67b26-285">Pokud má typ zdroje stejnou velikost jako cílový typ, pak je zdrojová hodnota zpracována jako hodnota cílového typu.</span><span class="sxs-lookup"><span data-stu-id="67b26-285">If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</span></span>
*  <span data-ttu-id="67b26-286">Pro převod z `decimal` na celočíselný typ je zdrojová hodnota zaokrouhlena směrem k nule na nejbližší celočíselnou hodnotu a tato integrální hodnota se bude výsledkem převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-286">For a conversion from `decimal` to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion.</span></span> <span data-ttu-id="67b26-287">Pokud výsledná celočíselná hodnota je mimo rozsah cílového typu, je vyvolána `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="67b26-287">If the resulting integral value is outside the range of the destination type, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="67b26-288">Pro převod z `float` nebo `double` na celočíselný typ je zpracování závislé na kontextu kontroly přetečení ([kontrolované a nezaškrtnuté operátory](expressions.md#the-checked-and-unchecked-operators)), ve kterých se převod provádí:</span><span class="sxs-lookup"><span data-stu-id="67b26-288">For a conversion from `float` or `double` to an integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="67b26-289">V kontextu `checked` převod pokračuje následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="67b26-289">In a `checked` context, the conversion proceeds as follows:</span></span>
        * <span data-ttu-id="67b26-290">Pokud je hodnota operandu NaN nebo Infinite, je vyvolána `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="67b26-290">If the value of the operand is NaN or infinite, a `System.OverflowException` is thrown.</span></span>
        * <span data-ttu-id="67b26-291">V opačném případě je zdrojový operand zaokrouhlen směrem k nule na nejbližší celočíselnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="67b26-291">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="67b26-292">Pokud je tato celočíselná hodnota v rozsahu cílového typu, pak je tato hodnota výsledkem převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-292">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="67b26-293">V opačném případě je vyvolána `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="67b26-293">Otherwise, a `System.OverflowException` is thrown.</span></span>
    * <span data-ttu-id="67b26-294">V kontextu `unchecked` je převod vždy úspěšný a pokračuje následujícím způsobem.</span><span class="sxs-lookup"><span data-stu-id="67b26-294">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="67b26-295">Pokud je hodnota operandu NaN nebo Infinite, výsledek převodu je nespecifikovaná hodnota cílového typu.</span><span class="sxs-lookup"><span data-stu-id="67b26-295">If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</span></span>
        * <span data-ttu-id="67b26-296">V opačném případě je zdrojový operand zaokrouhlen směrem k nule na nejbližší celočíselnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="67b26-296">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="67b26-297">Pokud je tato celočíselná hodnota v rozsahu cílového typu, pak je tato hodnota výsledkem převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-297">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="67b26-298">V opačném případě je výsledkem převodu nespecifikovaná hodnota cílového typu.</span><span class="sxs-lookup"><span data-stu-id="67b26-298">Otherwise, the result of the conversion is an unspecified value of the destination type.</span></span>
*  <span data-ttu-id="67b26-299">Pro převod z `double` na `float`se hodnota `double` zaokrouhluje na nejbližší `float` hodnotu.</span><span class="sxs-lookup"><span data-stu-id="67b26-299">For a conversion from `double` to `float`, the `double` value is rounded to the nearest `float` value.</span></span> <span data-ttu-id="67b26-300">Pokud je hodnota `double` příliš malá, aby byla reprezentována jako `float`, výsledkem bude kladné nula nebo záporné nula.</span><span class="sxs-lookup"><span data-stu-id="67b26-300">If the `double` value is too small to represent as a `float`, the result becomes positive zero or negative zero.</span></span> <span data-ttu-id="67b26-301">Pokud je hodnota `double` příliš velká, aby reprezentovala jako `float`, výsledkem bude kladné nekonečno nebo záporné nekonečno.</span><span class="sxs-lookup"><span data-stu-id="67b26-301">If the `double` value is too large to represent as a `float`, the result becomes positive infinity or negative infinity.</span></span> <span data-ttu-id="67b26-302">Pokud je hodnota `double` NaN, výsledek je také NaN.</span><span class="sxs-lookup"><span data-stu-id="67b26-302">If the `double` value is NaN, the result is also NaN.</span></span>
*  <span data-ttu-id="67b26-303">Pro převod z `float` nebo `double` na `decimal`je zdrojová hodnota převedena na `decimal` reprezentaci a zaokrouhlena na nejbližší číslo po 28 desetinné místo, pokud je to požadováno ([typ Decimal](types.md#the-decimal-type)).</span><span class="sxs-lookup"><span data-stu-id="67b26-303">For a conversion from `float` or `double` to `decimal`, the source value is converted to `decimal` representation and rounded to the nearest number after the 28th decimal place if required ([The decimal type](types.md#the-decimal-type)).</span></span> <span data-ttu-id="67b26-304">Pokud je zdrojová hodnota příliš malá, aby byla reprezentována jako `decimal`, výsledkem bude nula.</span><span class="sxs-lookup"><span data-stu-id="67b26-304">If the source value is too small to represent as a `decimal`, the result becomes zero.</span></span> <span data-ttu-id="67b26-305">Pokud je zdrojová hodnota NaN, Infinite nebo příliš velká, aby představovala jako `decimal`, je vyvolána `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="67b26-305">If the source value is NaN, infinity, or too large to represent as a `decimal`, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="67b26-306">Pro převod z `decimal` na `float` nebo `double`se hodnota `decimal` zaokrouhluje na nejbližší `double` nebo `float` hodnotu.</span><span class="sxs-lookup"><span data-stu-id="67b26-306">For a conversion from `decimal` to `float` or `double`, the `decimal` value is rounded to the nearest `double` or `float` value.</span></span> <span data-ttu-id="67b26-307">I když tento převod může přijít o přesnost, nikdy nezpůsobí vyvolání výjimky.</span><span class="sxs-lookup"><span data-stu-id="67b26-307">While this conversion may lose precision, it never causes an exception to be thrown.</span></span>

### <a name="explicit-enumeration-conversions"></a><span data-ttu-id="67b26-308">Explicitní převody výčtu</span><span class="sxs-lookup"><span data-stu-id="67b26-308">Explicit enumeration conversions</span></span>

<span data-ttu-id="67b26-309">Explicitní převody výčtu jsou:</span><span class="sxs-lookup"><span data-stu-id="67b26-309">The explicit enumeration conversions are:</span></span>

*  <span data-ttu-id="67b26-310">Z `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`*nebo `decimal` na enum_type.*</span><span class="sxs-lookup"><span data-stu-id="67b26-310">From `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal` to any *enum_type*.</span></span>
*  <span data-ttu-id="67b26-311">Z libovolného *enum_type* na `sbyte`, `byte``short`, `ushort``int``uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal`nebo.</span><span class="sxs-lookup"><span data-stu-id="67b26-311">From any *enum_type* to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="67b26-312">Z libovolného *enum_type* na jakékoli jiné *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="67b26-312">From any *enum_type* to any other *enum_type*.</span></span>

<span data-ttu-id="67b26-313">Explicitní převod výčtu mezi dvěma typy je zpracováván tím, že se všechny účastnící *enum_type* jako podkladový typ, který *enum_type*a následně provádí implicitní nebo explicitní číselný převod mezi výslednými typy.</span><span class="sxs-lookup"><span data-stu-id="67b26-313">An explicit enumeration conversion between two types is processed by treating any participating *enum_type* as the underlying type of that *enum_type*, and then performing an implicit or explicit numeric conversion between the resulting types.</span></span> <span data-ttu-id="67b26-314">Například vzhledem k *enum_type* `E` a základního typu `int`je převod z `E` na `byte` zpracován jako explicitní číselný převod ([explicitní číselné převody](conversions.md#explicit-numeric-conversions)) z `int` na `byte`a převod z `byte` na `E` je zpracován jako implicitní číselný převod ([implicitní číselné převody](conversions.md#implicit-numeric-conversions)) z `byte` na `int`.</span><span class="sxs-lookup"><span data-stu-id="67b26-314">For example, given an *enum_type* `E` with and underlying type of `int`, a conversion from `E` to `byte` is processed as an explicit numeric conversion ([Explicit numeric conversions](conversions.md#explicit-numeric-conversions)) from `int` to `byte`, and a conversion from `byte` to `E` is processed as an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) from `byte` to `int`.</span></span>

### <a name="explicit-nullable-conversions"></a><span data-ttu-id="67b26-315">Explicitní převody s možnou hodnotou null</span><span class="sxs-lookup"><span data-stu-id="67b26-315">Explicit nullable conversions</span></span>

<span data-ttu-id="67b26-316">***Explicitní převody s možnou hodnotou null*** umožňují předdefinovaným explicitním převodům, které pracují s typy hodnot, které neumožňují hodnotu null, použity také s hodnotou null formulářů těchto typů</span><span class="sxs-lookup"><span data-stu-id="67b26-316">***Explicit nullable conversions*** permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types.</span></span> <span data-ttu-id="67b26-317">Pro každé z předdefinovaných explicitních převodů, které převádějí typ hodnoty, která není null, `S` na typ hodnoty, který neumožňuje hodnotu null `T` ([převod identity](conversions.md#identity-conversion), [implicitní číselné převody](conversions.md#implicit-numeric-conversions), [implicitní převody výčtu](conversions.md#implicit-enumeration-conversions), [explicitní číselné převody](conversions.md#explicit-numeric-conversions)a [explicitní převody výčtu](conversions.md#explicit-enumeration-conversions)), existují následující převody s možnou hodnotou null:</span><span class="sxs-lookup"><span data-stu-id="67b26-317">For each of the predefined explicit conversions that convert from a non-nullable value type `S` to a non-nullable value type `T` ([Identity conversion](conversions.md#identity-conversion), [Implicit numeric conversions](conversions.md#implicit-numeric-conversions), [Implicit enumeration conversions](conversions.md#implicit-enumeration-conversions), [Explicit numeric conversions](conversions.md#explicit-numeric-conversions), and [Explicit enumeration conversions](conversions.md#explicit-enumeration-conversions)), the following nullable conversions exist:</span></span>

*  <span data-ttu-id="67b26-318">Explicitní převod z `S?` na `T?`.</span><span class="sxs-lookup"><span data-stu-id="67b26-318">An explicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="67b26-319">Explicitní převod z `S` na `T?`.</span><span class="sxs-lookup"><span data-stu-id="67b26-319">An explicit conversion from `S` to `T?`.</span></span>
*  <span data-ttu-id="67b26-320">Explicitní převod z `S?` na `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-320">An explicit conversion from `S?` to `T`.</span></span>

<span data-ttu-id="67b26-321">Vyhodnocení převodu s možnou hodnotou null na základě základní konverze z `S` na `T` pokračuje následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="67b26-321">Evaluation of a nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="67b26-322">Pokud je převod s možnou hodnotou null z `S?` na `T?`:</span><span class="sxs-lookup"><span data-stu-id="67b26-322">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="67b26-323">Pokud má zdrojová hodnota hodnotu null (`HasValue` vlastnost je false), výsledkem je hodnota null typu `T?`.</span><span class="sxs-lookup"><span data-stu-id="67b26-323">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="67b26-324">V opačném případě se převod vyhodnotí jako rozbalení z `S?` na `S`a za ním následuje základní převod z `S` na `T`a za ním i zalomení z `T` na `T?`.</span><span class="sxs-lookup"><span data-stu-id="67b26-324">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="67b26-325">Pokud je převod s možnou hodnotou null z `S` na `T?`, převod se vyhodnotí jako základní převod z `S` na `T` následovaný zalomením z `T` na `T?`.</span><span class="sxs-lookup"><span data-stu-id="67b26-325">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="67b26-326">Pokud je převod s možnou hodnotou null z `S?` na `T`, převod se vyhodnotí jako rozbalení z `S?` na `S` následované podkladovým převodem z `S` na `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-326">If the nullable conversion is from `S?` to `T`, the conversion is evaluated as an unwrapping from `S?` to `S` followed by the underlying conversion from `S` to `T`.</span></span>

<span data-ttu-id="67b26-327">Všimněte si, že pokus o rozbalení hodnoty s možnou hodnotou null vyvolá výjimku, pokud je hodnota `null`.</span><span class="sxs-lookup"><span data-stu-id="67b26-327">Note that an attempt to unwrap a nullable value will throw an exception if the value is `null`.</span></span>

### <a name="explicit-reference-conversions"></a><span data-ttu-id="67b26-328">Explicitní převody odkazů</span><span class="sxs-lookup"><span data-stu-id="67b26-328">Explicit reference conversions</span></span>

<span data-ttu-id="67b26-329">Explicitní převody odkazů:</span><span class="sxs-lookup"><span data-stu-id="67b26-329">The explicit reference conversions are:</span></span>

*  <span data-ttu-id="67b26-330">Z `object` a `dynamic` na jiné *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="67b26-330">From `object` and `dynamic` to any other *reference_type*.</span></span>
*  <span data-ttu-id="67b26-331">Z jakéhokoli *class_type* `S` na všechny *class_type* `T`jsou zadané `S` základní třídou `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-331">From any *class_type* `S` to any *class_type* `T`, provided `S` is a base class of `T`.</span></span>
*  <span data-ttu-id="67b26-332">Z jakéhokoli *class_type* `S` na jakýkoli *interface_type* `T`zadaný `S` není zapečetěný a poskytnutý `S` neimplementuje `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-332">From any *class_type* `S` to any *interface_type* `T`, provided `S` is not sealed and provided `S` does not implement `T`.</span></span>
*  <span data-ttu-id="67b26-333">Z jakéhokoli *interface_type* `S` na jakýkoli *class_type* `T`zadaný `T` není zapečetěný ani poskytnutý `T` implementuje `S`.</span><span class="sxs-lookup"><span data-stu-id="67b26-333">From any *interface_type* `S` to any *class_type* `T`, provided `T` is not sealed or provided `T` implements `S`.</span></span>
*  <span data-ttu-id="67b26-334">Z jakéhokoli *interface_type* `S` na jakýkoli *INTERFACE_TYPE* `T`, poskytnuté `S` nejsou odvozeny od `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-334">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is not derived from `T`.</span></span>
*  <span data-ttu-id="67b26-335">Z *array_type* `S` s typem elementu `SE` do *array_type* `T` s typem prvku `TE`, za předpokladu, že jsou splněny všechny následující podmínky:</span><span class="sxs-lookup"><span data-stu-id="67b26-335">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="67b26-336">`S` a `T` se liší pouze v typu prvku.</span><span class="sxs-lookup"><span data-stu-id="67b26-336">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="67b26-337">Jinými slovy, `S` a `T` mají stejný počet rozměrů.</span><span class="sxs-lookup"><span data-stu-id="67b26-337">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="67b26-338">`SE` i `TE` jsou *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="67b26-338">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="67b26-339">Pro `TE`existuje explicitní převod odkazu z `SE`.</span><span class="sxs-lookup"><span data-stu-id="67b26-339">An explicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="67b26-340">Z `System.Array` a rozhraní, která implementuje pro jakékoli *array_type*.</span><span class="sxs-lookup"><span data-stu-id="67b26-340">From `System.Array` and the interfaces it implements to any *array_type*.</span></span>
*  <span data-ttu-id="67b26-341">Z jednorozměrného typu pole `S[]` `System.Collections.Generic.IList<T>` a jeho základních rozhraní za předpokladu, že existuje explicitní referenční převod z `S` na `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-341">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an explicit reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="67b26-342">Z `System.Collections.Generic.IList<S>` a jeho základních rozhraní pro typ jednorozměrného pole `T[]`za předpokladu, že existuje explicitní identita nebo převod odkazu z `S` na `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-342">From `System.Collections.Generic.IList<S>` and its base interfaces to a single-dimensional array type `T[]`, provided that there is an explicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="67b26-343">Z `System.Delegate` a rozhraní, která implementuje pro jakékoli *delegate_type*.</span><span class="sxs-lookup"><span data-stu-id="67b26-343">From `System.Delegate` and the interfaces it implements to any *delegate_type*.</span></span>
*  <span data-ttu-id="67b26-344">Z typu odkazu na typ odkazu `T`, pokud má explicitní referenční převod na typ odkazu `T0` a `T0` má `T`převodu identity.</span><span class="sxs-lookup"><span data-stu-id="67b26-344">From a reference type to a reference type `T` if it has an explicit reference conversion to a reference type `T0` and `T0` has an identity conversion `T`.</span></span>
*  <span data-ttu-id="67b26-345">Z odkazového typu na typ rozhraní nebo delegáta `T`, pokud má explicitní referenční převod na typ rozhraní nebo delegáta `T0` a buď `T0` je variance-konvertibilní na `T` nebo `T` je variance-konvertibilní na `T0` ([Převod variance](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="67b26-345">From a reference type to an interface or delegate type `T` if it has an explicit reference conversion to an interface or delegate type `T0` and either `T0` is variance-convertible to `T` or `T` is variance-convertible to `T0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>
*  <span data-ttu-id="67b26-346">Z `D<S1...Sn>` `D<T1...Tn>`, kde `D<X1...Xn>` je obecný typ delegáta, `D<S1...Sn>` není kompatibilní s `D<T1...Tn>`nebo totožný s `Xi` a pro každý parametr typu `D` následující blokování:</span><span class="sxs-lookup"><span data-stu-id="67b26-346">From `D<S1...Sn>` to `D<T1...Tn>` where `D<X1...Xn>` is a generic delegate type, `D<S1...Sn>` is not compatible with or identical to `D<T1...Tn>`, and for each type parameter `Xi` of `D` the following holds:</span></span>
    * <span data-ttu-id="67b26-347">Pokud je `Xi` invariantní, `Si` je stejný jako `Ti`.</span><span class="sxs-lookup"><span data-stu-id="67b26-347">If `Xi` is invariant, then `Si` is identical to `Ti`.</span></span>
    * <span data-ttu-id="67b26-348">Pokud `Xi` je kovariantní, pak existuje implicitní nebo explicitní identita nebo převod odkazu z `Si` na `Ti`.</span><span class="sxs-lookup"><span data-stu-id="67b26-348">If `Xi` is covariant, then there is an implicit or explicit identity or reference conversion from `Si` to `Ti`.</span></span>
    * <span data-ttu-id="67b26-349">Pokud je `Xi` kontravariantní, pak `Si` a `Ti` jsou buď identické, nebo oba typy odkazů.</span><span class="sxs-lookup"><span data-stu-id="67b26-349">If `Xi` is contravariant, then `Si` and `Ti` are either identical or both reference types.</span></span>
*  <span data-ttu-id="67b26-350">Explicitní převody týkající se parametrů typu, které jsou známé jako odkazové typy.</span><span class="sxs-lookup"><span data-stu-id="67b26-350">Explicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="67b26-351">Další podrobnosti o explicitních převodech týkajících se parametrů typu naleznete v tématu [explicitní převody zahrnující parametry typu](conversions.md#explicit-conversions-involving-type-parameters).</span><span class="sxs-lookup"><span data-stu-id="67b26-351">For more details on explicit conversions involving type parameters, see [Explicit conversions involving type parameters](conversions.md#explicit-conversions-involving-type-parameters).</span></span>

<span data-ttu-id="67b26-352">Explicitní převod odkazů je převod mezi typy odkazů, které vyžadují kontroly za běhu, aby bylo zajištěno jejich správnosti.</span><span class="sxs-lookup"><span data-stu-id="67b26-352">The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</span></span>

<span data-ttu-id="67b26-353">Aby explicitní převod referencí mohl být v době běhu úspěšný, musí být hodnota zdrojového operandu `null`, nebo skutečný typ objektu, na který odkazuje zdrojový operand, musí být typ, který lze převést na cílový typ pomocí implicitního převodu odkazu ([implicitní převody odkazů](conversions.md#implicit-reference-conversions)) nebo převodu zabalení ([převody zabalení](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="67b26-353">For an explicit reference conversion to succeed at run-time, the value of the source operand must be `null`, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions)) or boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)).</span></span> <span data-ttu-id="67b26-354">Pokud dojde k chybě explicitního převodu odkazu, je vyvolána `System.InvalidCastException`.</span><span class="sxs-lookup"><span data-stu-id="67b26-354">If an explicit reference conversion fails, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="67b26-355">Převody odkazů, implicitní nebo explicitní, nikdy nezmění referenční identitu převáděného objektu.</span><span class="sxs-lookup"><span data-stu-id="67b26-355">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="67b26-356">Jinými slovy, zatímco převod odkazu může změnit typ odkazu, nikdy nemění typ nebo hodnotu objektu, na který je odkazováno.</span><span class="sxs-lookup"><span data-stu-id="67b26-356">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="67b26-357">Převody rozbalení</span><span class="sxs-lookup"><span data-stu-id="67b26-357">Unboxing conversions</span></span>

<span data-ttu-id="67b26-358">Převod rozbalení povoluje odkazový typ, který se explicitně převede na *value_type*.</span><span class="sxs-lookup"><span data-stu-id="67b26-358">An unboxing conversion permits a reference type to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="67b26-359">Převod rozbalení existuje z typů `object`, `dynamic` a `System.ValueType` do jakéhokoli *non_nullable_value_type*a z jakéhokoli *INTERFACE_TYPE* na *non_nullable_value_type* , který implementuje *INTERFACE_TYPE*.</span><span class="sxs-lookup"><span data-stu-id="67b26-359">An unboxing conversion exists from the types `object`, `dynamic` and `System.ValueType` to any *non_nullable_value_type*, and from any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span> <span data-ttu-id="67b26-360">Kromě toho `System.Enum` typ může být nezabalený do *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="67b26-360">Furthermore type `System.Enum` can be unboxed to any *enum_type*.</span></span>

<span data-ttu-id="67b26-361">Převod rozbalení existuje z typu odkazu na *nullable_type* , pokud převod rozbalení existuje z typu odkazu na podkladovou *non_nullable_value_type* *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="67b26-361">An unboxing conversion exists from a reference type to a *nullable_type* if an unboxing conversion exists from the reference type to the underlying *non_nullable_value_type* of the *nullable_type*.</span></span>

<span data-ttu-id="67b26-362">Typ hodnoty `S` má zabalení konverze z typu rozhraní `I`, pokud obsahuje převod rozbalení z typu rozhraní `I0` a `I0` má převod identity na `I`.</span><span class="sxs-lookup"><span data-stu-id="67b26-362">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="67b26-363">Typ hodnoty `S` má zabalení konverze z typu rozhraní `I` Pokud má převod rozbalení z rozhraní nebo typu delegáta `I0` a buď `I0` je variance-konvertibilní na `I` nebo `I` je variance-konvertibilní na `I0` ([Převod variance](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="67b26-363">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface or delegate type `I0` and either `I0` is variance-convertible to `I` or `I` is variance-convertible to `I0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>

<span data-ttu-id="67b26-364">Operace rozbalení se skládá z první kontroly, zda je instance objektu zabalenou hodnotou daného *value_type*a následným zkopírováním hodnoty z instance.</span><span class="sxs-lookup"><span data-stu-id="67b26-364">An unboxing operation consists of first checking that the object instance is a boxed value of the given *value_type*, and then copying the value out of the instance.</span></span> <span data-ttu-id="67b26-365">Rozbalení odkazu s hodnotou null na *nullable_type* vytvoří hodnotu null *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="67b26-365">Unboxing a null reference to a *nullable_type* produces the null value of the *nullable_type*.</span></span> <span data-ttu-id="67b26-366">Struktura může být z typu `System.ValueType`neohraničena, protože se jedná o základní třídu pro všechny struktury ([Dědičnost](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="67b26-366">A struct can be unboxed from the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="67b26-367">Převody rozbalení jsou podrobněji popsány v tématu [převody rozbalení](types.md#unboxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="67b26-367">Unboxing conversions are described further in [Unboxing conversions](types.md#unboxing-conversions).</span></span>

### <a name="explicit-dynamic-conversions"></a><span data-ttu-id="67b26-368">Explicitní dynamické převody</span><span class="sxs-lookup"><span data-stu-id="67b26-368">Explicit dynamic conversions</span></span>

<span data-ttu-id="67b26-369">Explicitní dynamický převod existuje ve výrazu typu `dynamic` na libovolný typ `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-369">An explicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="67b26-370">Převod je dynamicky svázán ([dynamická vazba](expressions.md#dynamic-binding)), což znamená, že explicitní převod bude vyžádán za běhu z běhového typu výrazu do `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-370">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="67b26-371">Pokud není nalezen žádný převod, je vyvolána výjimka za běhu.</span><span class="sxs-lookup"><span data-stu-id="67b26-371">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="67b26-372">Pokud dynamická vazba převodu není žádoucí, výraz může být nejprve převeden na `object`a následně na požadovaný typ.</span><span class="sxs-lookup"><span data-stu-id="67b26-372">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="67b26-373">Předpokládejme, že je definována následující třída:</span><span class="sxs-lookup"><span data-stu-id="67b26-373">Assume the following class is defined:</span></span>
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

<span data-ttu-id="67b26-374">Následující příklad ukazuje explicitní dynamické převody:</span><span class="sxs-lookup"><span data-stu-id="67b26-374">The following example illustrates explicit dynamic conversions:</span></span>
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

<span data-ttu-id="67b26-375">Nejlepší převod `o` na `C` byl nalezen v době kompilace, aby byl explicitním převodem odkazu.</span><span class="sxs-lookup"><span data-stu-id="67b26-375">The best conversion of `o` to `C` is found at compile-time to be an explicit reference conversion.</span></span> <span data-ttu-id="67b26-376">Tím dojde k chybě v době běhu, protože `"1"` není ve skutečnosti `C`.</span><span class="sxs-lookup"><span data-stu-id="67b26-376">This fails at run-time, because `"1"` is not in fact a `C`.</span></span> <span data-ttu-id="67b26-377">Konverze `d` na `C`, jako explicitní dynamický převod, je pozastavena za běhu, kde je nalezen uživatelem definovaný převod z běhového typu `d` -- `string`--na `C` a úspěch.</span><span class="sxs-lookup"><span data-stu-id="67b26-377">The conversion of `d` to `C` however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of `d` -- `string` -- to `C` is found, and succeeds.</span></span>

### <a name="explicit-conversions-involving-type-parameters"></a><span data-ttu-id="67b26-378">Explicitní převody týkající se parametrů typu</span><span class="sxs-lookup"><span data-stu-id="67b26-378">Explicit conversions involving type parameters</span></span>

<span data-ttu-id="67b26-379">Pro daný parametr typu existují následující explicitní převody `T`:</span><span class="sxs-lookup"><span data-stu-id="67b26-379">The following explicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="67b26-380">Od efektivní základní třídy `C` `T` do `T` a z jakékoli základní třídy `C` až `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-380">From the effective base class `C` of `T` to `T` and from any base class of `C` to `T`.</span></span> <span data-ttu-id="67b26-381">V době běhu, pokud je `T` typ hodnoty, je převod proveden jako převod rozbalení.</span><span class="sxs-lookup"><span data-stu-id="67b26-381">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="67b26-382">V opačném případě je převod proveden jako explicitní převod referencí nebo převod identity.</span><span class="sxs-lookup"><span data-stu-id="67b26-382">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="67b26-383">Z libovolného typu rozhraní `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-383">From any interface type to `T`.</span></span> <span data-ttu-id="67b26-384">V době běhu, pokud je `T` typ hodnoty, je převod proveden jako převod rozbalení.</span><span class="sxs-lookup"><span data-stu-id="67b26-384">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="67b26-385">V opačném případě je převod proveden jako explicitní převod referencí nebo převod identity.</span><span class="sxs-lookup"><span data-stu-id="67b26-385">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="67b26-386">Z `T` na jakékoli *interface_type* `I` nejsou k dispozici již implicitní převod z `T` na `I`.</span><span class="sxs-lookup"><span data-stu-id="67b26-386">From `T` to any *interface_type* `I` provided there is not already an implicit conversion from `T` to `I`.</span></span> <span data-ttu-id="67b26-387">V době běhu, pokud je `T` typ hodnoty, je převod proveden jako převod zabalení následovaný explicitním převodem odkazu.</span><span class="sxs-lookup"><span data-stu-id="67b26-387">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion.</span></span> <span data-ttu-id="67b26-388">V opačném případě je převod proveden jako explicitní převod referencí nebo převod identity.</span><span class="sxs-lookup"><span data-stu-id="67b26-388">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="67b26-389">Z parametru typu `U` do `T`je zadaný `T` závislý na `U` ([omezení parametrů typu](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="67b26-389">From a type parameter `U` to `T`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="67b26-390">V době běhu, pokud je `U` typ hodnoty, pak `T` a `U` jsou nutně stejného typu a není proveden žádný převod.</span><span class="sxs-lookup"><span data-stu-id="67b26-390">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="67b26-391">V opačném případě, pokud je `T` typ hodnoty, je převod proveden jako zabalení převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-391">Otherwise, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="67b26-392">V opačném případě je převod proveden jako explicitní převod referencí nebo převod identity.</span><span class="sxs-lookup"><span data-stu-id="67b26-392">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="67b26-393">Pokud je `T` známý jako typ odkazu, výše uvedené převody jsou klasifikovány jako explicitní převody odkazů ([explicitní převody odkazů](conversions.md#explicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="67b26-393">If `T` is known to be a reference type, the conversions above are all classified as explicit reference conversions ([Explicit reference conversions](conversions.md#explicit-reference-conversions)).</span></span> <span data-ttu-id="67b26-394">Pokud `T` není známý jako typ odkazu, převody uvedené výše jsou klasifikovány jako převody rozbalení ([převody rozbalení](conversions.md#unboxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="67b26-394">If `T` is not known to be a reference type, the conversions above are classified as unboxing conversions ([Unboxing conversions](conversions.md#unboxing-conversions)).</span></span>

<span data-ttu-id="67b26-395">Výše uvedená pravidla nepovolují přímý explicitní převod z neomezeného parametru typu na typ, který není typu rozhraní, který může být překvapivé.</span><span class="sxs-lookup"><span data-stu-id="67b26-395">The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising.</span></span> <span data-ttu-id="67b26-396">Důvodem pro toto pravidlo je zabránit nejasnostem a zajistit, aby sémantika takových převodů byla jasná.</span><span class="sxs-lookup"><span data-stu-id="67b26-396">The reason for this rule is to prevent confusion and make the semantics of such conversions clear.</span></span> <span data-ttu-id="67b26-397">Předpokládejme například následující deklaraci:</span><span class="sxs-lookup"><span data-stu-id="67b26-397">For example, consider the following declaration:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

<span data-ttu-id="67b26-398">Pokud byla povolená přímá explicitní konverze `t` na `int`, může jedna z nich jednoduše očekávat, že `X<int>.F(7)` vrátí `7L`.</span><span class="sxs-lookup"><span data-stu-id="67b26-398">If the direct explicit conversion of `t` to `int` were permitted, one might easily expect that `X<int>.F(7)` would return `7L`.</span></span> <span data-ttu-id="67b26-399">Nicméně to neplatí, protože standardní číselné převody jsou zváženy pouze v případě, že typy jsou známy v době vytváření vazby.</span><span class="sxs-lookup"><span data-stu-id="67b26-399">However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time.</span></span> <span data-ttu-id="67b26-400">Aby se sémantika jasně vymazala, je nutné, aby byl napsaný výše uvedený příklad:</span><span class="sxs-lookup"><span data-stu-id="67b26-400">In order to make the semantics clear, the above example must instead be written:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

<span data-ttu-id="67b26-401">Tento kód nyní zkompiluje, ale provede `X<int>.F(7)` by pak vyvolal výjimku za běhu, protože zabalený `int` nelze převést přímo na `long`.</span><span class="sxs-lookup"><span data-stu-id="67b26-401">This code will now compile but executing `X<int>.F(7)` would then throw an exception at run-time, since a boxed `int` cannot be converted directly to a `long`.</span></span>

### <a name="user-defined-explicit-conversions"></a><span data-ttu-id="67b26-402">Uživatelem definované explicitní převody</span><span class="sxs-lookup"><span data-stu-id="67b26-402">User-defined explicit conversions</span></span>

<span data-ttu-id="67b26-403">Uživatelem definovaný explicitní převod se skládá z volitelného standardního explicitního převodu, za nímž následuje spuštění uživatelsky definovaného implicitního nebo explicitního operátoru převodu následovaný jiným volitelným standardním explicitním převodem.</span><span class="sxs-lookup"><span data-stu-id="67b26-403">A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion.</span></span> <span data-ttu-id="67b26-404">Přesná pravidla pro vyhodnocení uživatelem definovaných explicitních převodů jsou popsány ve [zpracování uživatelem definovaných explicitních převodů](conversions.md#processing-of-user-defined-explicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="67b26-404">The exact rules for evaluating user-defined explicit conversions are described in [Processing of user-defined explicit conversions](conversions.md#processing-of-user-defined-explicit-conversions).</span></span>

## <a name="standard-conversions"></a><span data-ttu-id="67b26-405">Standardní převody</span><span class="sxs-lookup"><span data-stu-id="67b26-405">Standard conversions</span></span>

<span data-ttu-id="67b26-406">Standardní převody jsou takové předdefinované převody, které mohou nastat jako součást uživatelsky definovaného převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-406">The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</span></span>

### <a name="standard-implicit-conversions"></a><span data-ttu-id="67b26-407">Standardní implicitní převody</span><span class="sxs-lookup"><span data-stu-id="67b26-407">Standard implicit conversions</span></span>

<span data-ttu-id="67b26-408">Následující implicitní převody jsou klasifikovány jako standardní implicitní převody:</span><span class="sxs-lookup"><span data-stu-id="67b26-408">The following implicit conversions are classified as standard implicit conversions:</span></span>

*  <span data-ttu-id="67b26-409">Převody identity ([převod identity](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="67b26-409">Identity conversions ([Identity conversion](conversions.md#identity-conversion))</span></span>
*  <span data-ttu-id="67b26-410">Implicitní číselné převody ([implicitní číselné převody](conversions.md#implicit-numeric-conversions))</span><span class="sxs-lookup"><span data-stu-id="67b26-410">Implicit numeric conversions ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions))</span></span>
*  <span data-ttu-id="67b26-411">Implicitní převody povolující hodnotu null ([implicitní převody s možnou hodnotou null](conversions.md#implicit-nullable-conversions))</span><span class="sxs-lookup"><span data-stu-id="67b26-411">Implicit nullable conversions ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions))</span></span>
*  <span data-ttu-id="67b26-412">Implicitní převody odkazů ([implicitní převody odkazů](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="67b26-412">Implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
*  <span data-ttu-id="67b26-413">Převody zabalení ([převody zabalení](conversions.md#boxing-conversions))</span><span class="sxs-lookup"><span data-stu-id="67b26-413">Boxing conversions ([Boxing conversions](conversions.md#boxing-conversions))</span></span>
*  <span data-ttu-id="67b26-414">Implicitní převody konstantních výrazů ([implicitní dynamické převody](conversions.md#implicit-dynamic-conversions))</span><span class="sxs-lookup"><span data-stu-id="67b26-414">Implicit constant expression conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions))</span></span>
*  <span data-ttu-id="67b26-415">Implicitní převody zahrnující parametry typu ([implicitní převody zahrnující parametry typu](conversions.md#implicit-conversions-involving-type-parameters))</span><span class="sxs-lookup"><span data-stu-id="67b26-415">Implicit conversions involving type parameters ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters))</span></span>

<span data-ttu-id="67b26-416">Standardní implicitní převody konkrétně vylučují uživatelem definované implicitní převody.</span><span class="sxs-lookup"><span data-stu-id="67b26-416">The standard implicit conversions specifically exclude user-defined implicit conversions.</span></span>

### <a name="standard-explicit-conversions"></a><span data-ttu-id="67b26-417">Standardní explicitní převody</span><span class="sxs-lookup"><span data-stu-id="67b26-417">Standard explicit conversions</span></span>

<span data-ttu-id="67b26-418">Standardní explicitní převody jsou všechny standardní implicitní převody a podmnožina explicitních převodů, pro které existuje opačný standardní implicitní převod.</span><span class="sxs-lookup"><span data-stu-id="67b26-418">The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists.</span></span> <span data-ttu-id="67b26-419">Jinými slovy, pokud standardní implicitní převod existuje z typu `A` na `B`typu, pak standardní explicitní převod existuje z typu `A` na typ `B` a z typu `B` na typ `A`.</span><span class="sxs-lookup"><span data-stu-id="67b26-419">In other words, if a standard implicit conversion exists from a type `A` to a type `B`, then a standard explicit conversion exists from type `A` to type `B` and from type `B` to type `A`.</span></span>

## <a name="user-defined-conversions"></a><span data-ttu-id="67b26-420">Uživatelem definované převody</span><span class="sxs-lookup"><span data-stu-id="67b26-420">User-defined conversions</span></span>

<span data-ttu-id="67b26-421">C#umožňuje rozšířit předdefinované implicitní a explicitní převody na základě ***uživatelsky definovaných převodů***.</span><span class="sxs-lookup"><span data-stu-id="67b26-421">C# allows the pre-defined implicit and explicit conversions to be augmented by ***user-defined conversions***.</span></span> <span data-ttu-id="67b26-422">Uživatelsky definované převody jsou zavedeny deklarováním operátorů převodu ([operátory převodu](classes.md#conversion-operators)) v typech třídy a struktury.</span><span class="sxs-lookup"><span data-stu-id="67b26-422">User-defined conversions are introduced by declaring conversion operators ([Conversion operators](classes.md#conversion-operators)) in class and struct types.</span></span>

### <a name="permitted-user-defined-conversions"></a><span data-ttu-id="67b26-423">Povolené uživatelsky definované převody</span><span class="sxs-lookup"><span data-stu-id="67b26-423">Permitted user-defined conversions</span></span>

<span data-ttu-id="67b26-424">C#povoluje deklaraci určitých uživatelsky definovaných převodů.</span><span class="sxs-lookup"><span data-stu-id="67b26-424">C# permits only certain user-defined conversions to be declared.</span></span> <span data-ttu-id="67b26-425">Konkrétně není možné předefinovat již existující implicitní nebo explicitní převod.</span><span class="sxs-lookup"><span data-stu-id="67b26-425">In particular, it is not possible to redefine an already existing implicit or explicit conversion.</span></span>

<span data-ttu-id="67b26-426">Pro daný typ zdroje `S` a cílový typ `T`, pokud `S` nebo `T` jsou typy s možnou hodnotou null, nechejte `S0` a `T0` odkazují na jejich podkladové typy, jinak `S0` a `T0` jsou rovny `S` a `T` v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="67b26-426">For a given source type `S` and target type `T`, if `S` or `T` are nullable types, let `S0` and `T0` refer to their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span> <span data-ttu-id="67b26-427">Třída nebo struktura je oprávněna deklarovat převod ze zdrojového typu `S` na cílový typ `T` pouze v případě, že jsou splněny všechny následující podmínky:</span><span class="sxs-lookup"><span data-stu-id="67b26-427">A class or struct is permitted to declare a conversion from a source type `S` to a target type `T` only if all of the following are true:</span></span>

*  <span data-ttu-id="67b26-428">`S0` a `T0` jsou různé typy.</span><span class="sxs-lookup"><span data-stu-id="67b26-428">`S0` and `T0` are different types.</span></span>
*  <span data-ttu-id="67b26-429">`S0` nebo `T0` je typ třídy nebo struktury, ve které se provádí deklarace operátoru.</span><span class="sxs-lookup"><span data-stu-id="67b26-429">Either `S0` or `T0` is the class or struct type in which the operator declaration takes place.</span></span>
*  <span data-ttu-id="67b26-430">Ani `S0` ani `T0` není *INTERFACE_TYPE*.</span><span class="sxs-lookup"><span data-stu-id="67b26-430">Neither `S0` nor `T0` is an *interface_type*.</span></span>
*  <span data-ttu-id="67b26-431">S výjimkou uživatelem definovaných převodů neexistuje převod z `S` na `T` nebo z `T` na `S`.</span><span class="sxs-lookup"><span data-stu-id="67b26-431">Excluding user-defined conversions, a conversion does not exist from `S` to `T` or from `T` to `S`.</span></span>

<span data-ttu-id="67b26-432">Omezení, která platí pro uživatelem definované převody, jsou podrobněji popsána v části [operátory převodu](classes.md#conversion-operators).</span><span class="sxs-lookup"><span data-stu-id="67b26-432">The restrictions that apply to user-defined conversions are discussed further in [Conversion operators](classes.md#conversion-operators).</span></span>

### <a name="lifted-conversion-operators"></a><span data-ttu-id="67b26-433">Zrušené operátory převodu</span><span class="sxs-lookup"><span data-stu-id="67b26-433">Lifted conversion operators</span></span>

<span data-ttu-id="67b26-434">Předaný uživatelsky definovaný operátor převodu, který se převede z typu hodnoty, která není null, `S` na `T`typu hodnoty, který není null, existuje převedený ***operátor převodu*** , který se převede z `S?` na `T?`.</span><span class="sxs-lookup"><span data-stu-id="67b26-434">Given a user-defined conversion operator that converts from a non-nullable value type `S` to a non-nullable value type `T`, a ***lifted conversion operator*** exists that converts from `S?` to `T?`.</span></span> <span data-ttu-id="67b26-435">Tento operátor převedený převod provádí rozbalení z `S?` na `S` následovaný uživatelem definovaným převodem z `S` na `T` následovaným zalomením z `T` na `T?`, s tím rozdílem, že hodnota null `S?` převádí přímo na `T?`vracející hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="67b26-435">This lifted conversion operator performs an unwrapping from `S?` to `S` followed by the user-defined conversion from `S` to `T` followed by a wrapping from `T` to `T?`, except that a null valued `S?` converts directly to a null valued `T?`.</span></span>

<span data-ttu-id="67b26-436">Předaný operátor převodu má stejnou implicitní nebo explicitní klasifikaci jako svůj základní uživatelsky definovaný operátor převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-436">A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.</span></span> <span data-ttu-id="67b26-437">Pojem "uživatelsky definovaný převod" se vztahuje na použití uživatelsky definovaných i převedených operátorů převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-437">The term "user-defined conversion" applies to the use of both user-defined and lifted conversion operators.</span></span>

### <a name="evaluation-of-user-defined-conversions"></a><span data-ttu-id="67b26-438">Vyhodnocení uživatelem definovaných převodů</span><span class="sxs-lookup"><span data-stu-id="67b26-438">Evaluation of user-defined conversions</span></span>

<span data-ttu-id="67b26-439">Uživatelsky definovaný převod převede hodnotu z jejího typu označovaného jako ***typ zdroje***na jiný typ, který se nazývá ***cílový typ***.</span><span class="sxs-lookup"><span data-stu-id="67b26-439">A user-defined conversion converts a value from its type, called the ***source type***, to another type, called the ***target type***.</span></span> <span data-ttu-id="67b26-440">Vyhodnocení uživatelem definovaných převodových Center při hledání ***nejpřesnější uživatelsky*** definovaného operátoru převodu pro konkrétní zdrojové a cílové typy.</span><span class="sxs-lookup"><span data-stu-id="67b26-440">Evaluation of a user-defined conversion centers on finding the ***most specific*** user-defined conversion operator for the particular source and target types.</span></span> <span data-ttu-id="67b26-441">Toto určení je rozdělené do několika kroků:</span><span class="sxs-lookup"><span data-stu-id="67b26-441">This determination is broken into several steps:</span></span>

*  <span data-ttu-id="67b26-442">Hledání sady tříd a struktur, ze kterých se budou brát v úvahu uživatelsky definované operátory převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-442">Finding the set of classes and structs from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="67b26-443">Tato sada se skládá ze zdrojového typu a jeho základních tříd a cílového typu a jeho základních tříd (s implicitními předpoklady, které pouze třídy a struktury mohou deklarovat uživatelsky definované operátory a které typy bez třídy nemají žádné základní třídy).</span><span class="sxs-lookup"><span data-stu-id="67b26-443">This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes).</span></span> <span data-ttu-id="67b26-444">Pro účely tohoto kroku, pokud je zdroj nebo cílový typ *nullable_type*, místo toho se použije jejich podkladový typ.</span><span class="sxs-lookup"><span data-stu-id="67b26-444">For the purposes of this step, if either the source or target type is a *nullable_type*, their underlying type is used instead.</span></span>
*  <span data-ttu-id="67b26-445">Z této sady typů určete, které uživatelsky definované a přenesené operátory převodu jsou platné.</span><span class="sxs-lookup"><span data-stu-id="67b26-445">From that set of types, determining which user-defined and lifted conversion operators are applicable.</span></span> <span data-ttu-id="67b26-446">Pro operátor převodu musí být možné provést standardní převod ([standardní převody](conversions.md#standard-conversions)) ze zdrojového typu na typ operandu operátoru a musí být možné provést standardní převod z výsledného typu operátoru na cílový typ.</span><span class="sxs-lookup"><span data-stu-id="67b26-446">For a conversion operator to be applicable, it must be possible to perform a standard conversion ([Standard conversions](conversions.md#standard-conversions)) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</span></span>
*  <span data-ttu-id="67b26-447">Ze sady příslušných uživatelsky definovaných operátorů určete, který operátor je jednoznačně určený.</span><span class="sxs-lookup"><span data-stu-id="67b26-447">From the set of applicable user-defined operators, determining which operator is unambiguously the most specific.</span></span> <span data-ttu-id="67b26-448">Obecně platí, že nejpřesnější operátor je operátor, jehož typ operandu je "nejbližší" ke zdrojovému typu a jehož výsledný typ je "nejbližší" cílovému typu.</span><span class="sxs-lookup"><span data-stu-id="67b26-448">In general terms, the most specific operator is the operator whose operand type is "closest" to the source type and whose result type is "closest" to the target type.</span></span> <span data-ttu-id="67b26-449">Uživatelsky definované operátory převodu jsou upřednostňovány přes přenesené operátory převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-449">User-defined conversion operators are preferred over lifted conversion operators.</span></span> <span data-ttu-id="67b26-450">Přesná pravidla pro určení nejpřesnější uživatelsky definovaného operátoru převodu jsou definována v následujících oddílech.</span><span class="sxs-lookup"><span data-stu-id="67b26-450">The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</span></span>

<span data-ttu-id="67b26-451">Po identifikaci uživatelsky definovaného operátoru převodu, který představuje uživatelsky definovaný převod, se zobrazí až tři kroky:</span><span class="sxs-lookup"><span data-stu-id="67b26-451">Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</span></span>

*  <span data-ttu-id="67b26-452">Nejprve v případě potřeby proveďte standardní převod ze zdrojového typu na typ operandu uživatelem definovaného nebo převedené operátoru převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-452">First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</span></span>
*  <span data-ttu-id="67b26-453">V dalším kroku vyvoláte uživatelem definovaný nebo převedený operátor převodu k provedení převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-453">Next, invoking the user-defined or lifted conversion operator to perform the conversion.</span></span>
*  <span data-ttu-id="67b26-454">Nakonec v případě potřeby proveďte standardní převod z typu výsledku operátoru převodu definovaného uživatelem nebo převedený na cílový typ.</span><span class="sxs-lookup"><span data-stu-id="67b26-454">Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</span></span>

<span data-ttu-id="67b26-455">Vyhodnocení uživatelsky definovaného převodu nikdy nezahrnuje více než jednoho uživatelsky definovaného nebo přecházejícího operátoru převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-455">Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator.</span></span> <span data-ttu-id="67b26-456">Jinými slovy převod typu `S` na typ `T` nikdy nespustí uživatelem definovaný převod z `S` na `X` a pak provede uživatelem definovaný převod z `X` na `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-456">In other words, a conversion from type `S` to type `T` will never first execute a user-defined conversion from `S` to `X` and then execute a user-defined conversion from `X` to `T`.</span></span>

<span data-ttu-id="67b26-457">Přesné definice vyhodnocení uživatelem definovaných implicitních nebo explicitních převodů jsou uvedeny v následujících oddílech.</span><span class="sxs-lookup"><span data-stu-id="67b26-457">Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections.</span></span> <span data-ttu-id="67b26-458">Definice využívají následující pojmy:</span><span class="sxs-lookup"><span data-stu-id="67b26-458">The definitions make use of the following terms:</span></span>

*  <span data-ttu-id="67b26-459">Pokud standardní implicitní převod ([standardní implicitní převody](conversions.md#standard-implicit-conversions)) existuje z typu `A` na typ `B`a v případě, že ani `A` ani `B` nejsou *INTERFACE_TYPE*s, pak `A` se bude ***považovat za `B`a*** `B` se ***říká `A`.***</span><span class="sxs-lookup"><span data-stu-id="67b26-459">If a standard implicit conversion ([Standard implicit conversions](conversions.md#standard-implicit-conversions)) exists from a type `A` to a type `B`, and if neither `A` nor `B` are *interface_type*s, then `A` is said to be ***encompassed by*** `B`, and `B` is said to ***encompass*** `A`.</span></span>
*  <span data-ttu-id="67b26-460">***Nejvíce zahrnuje typ*** v sadě typů je jeden typ, který zahrnuje všechny ostatní typy v sadě.</span><span class="sxs-lookup"><span data-stu-id="67b26-460">The ***most encompassing type*** in a set of types is the one type that encompasses all other types in the set.</span></span> <span data-ttu-id="67b26-461">Pokud žádný jednotlivý typ neobsahuje všechny ostatní typy, pak sada neobsahuje žádné typy, které by zahrnovaly.</span><span class="sxs-lookup"><span data-stu-id="67b26-461">If no single type encompasses all other types, then the set has no most encompassing type.</span></span> <span data-ttu-id="67b26-462">Ve více intuitivních případech je největším typem v množině "největší" typ v sadě – jeden typ, na který lze všechny ostatní typy implicitně převést.</span><span class="sxs-lookup"><span data-stu-id="67b26-462">In more intuitive terms, the most encompassing type is the "largest" type in the set—the one type to which each of the other types can be implicitly converted.</span></span>
*  <span data-ttu-id="67b26-463">***Nejvýznamnější typ*** v sadě typů je jeden typ, který je zahrnut ve všech ostatních typech v sadě.</span><span class="sxs-lookup"><span data-stu-id="67b26-463">The ***most encompassed type*** in a set of types is the one type that is encompassed by all other types in the set.</span></span> <span data-ttu-id="67b26-464">Pokud žádný jednotlivý typ není zahrnut ve všech ostatních typech, pak sada nemá nejvíce zahrnující typ.</span><span class="sxs-lookup"><span data-stu-id="67b26-464">If no single type is encompassed by all other types, then the set has no most encompassed type.</span></span> <span data-ttu-id="67b26-465">Ve více intuitivních výrazech se nejčastěji zahrnuje typ "nejmenší" typ v sadě – jeden typ, který lze implicitně převést na každý z ostatních typů.</span><span class="sxs-lookup"><span data-stu-id="67b26-465">In more intuitive terms, the most encompassed type is the "smallest" type in the set—the one type that can be implicitly converted to each of the other types.</span></span>

### <a name="processing-of-user-defined-implicit-conversions"></a><span data-ttu-id="67b26-466">Zpracování implicitních převodů definovaných uživatelem</span><span class="sxs-lookup"><span data-stu-id="67b26-466">Processing of user-defined implicit conversions</span></span>

<span data-ttu-id="67b26-467">Uživatelem definovaný implicitní převod z typu `S` na typ `T` je zpracován následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="67b26-467">A user-defined implicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="67b26-468">Určete typy `S0` a `T0`.</span><span class="sxs-lookup"><span data-stu-id="67b26-468">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="67b26-469">Pokud `S` nebo `T` jsou typy s možnou hodnotou null, `S0` a `T0` jsou jejich podkladové typy, jinak `S0` a `T0` jsou rovny `S` a `T` v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="67b26-469">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="67b26-470">Najde sadu typů `D`, ze kterých se budou brát v úvahu uživatelsky definované operátory převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-470">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="67b26-471">Tato sada se skládá z `S0` (Pokud `S0` je třída nebo struktura), základní třídy `S0` (Pokud `S0` je třída) a `T0` (Pokud `T0` je třída nebo struktura).</span><span class="sxs-lookup"><span data-stu-id="67b26-471">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), and `T0` (if `T0` is a class or struct).</span></span>
*  <span data-ttu-id="67b26-472">Najděte sadu příslušných uživatelsky definovaných a přenesených operátorů převodu `U`.</span><span class="sxs-lookup"><span data-stu-id="67b26-472">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="67b26-473">Tato sada se skládá z uživatelem definovaných a převedených implicitních operátorů převodu deklarovaných třídami nebo strukturami v `D`, které převádějí z typu, který zahrnuje `S` na typ, který je zahrnut `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-473">This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing `S` to a type encompassed by `T`.</span></span> <span data-ttu-id="67b26-474">Pokud je `U` prázdné, převod není definován a dojde k chybě při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="67b26-474">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="67b26-475">Vyhledá nejvíce konkrétní typ zdroje `SX`operátory v `U`:</span><span class="sxs-lookup"><span data-stu-id="67b26-475">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="67b26-476">Pokud některý z operátorů v `U` převést z `S`, `SX` `S`.</span><span class="sxs-lookup"><span data-stu-id="67b26-476">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="67b26-477">V opačném případě `SX` je nejčastěji zahrnující typ v kombinované sadě zdrojových typů operátorů v `U`.</span><span class="sxs-lookup"><span data-stu-id="67b26-477">Otherwise, `SX` is the most encompassed type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="67b26-478">Pokud nelze nalézt přesně jeden z výše zahrnutého typu, převod je nejednoznačný a dojde k chybě při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="67b26-478">If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="67b26-479">Vyhledá nejvíce konkrétní cílový typ `TX`operátory v `U`:</span><span class="sxs-lookup"><span data-stu-id="67b26-479">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="67b26-480">Pokud některý z operátorů v `U` převést na `T`, `TX` `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-480">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="67b26-481">V opačném případě je `TX` nejběžnějším typem v kombinované sadě cílových typů operátorů v `U`.</span><span class="sxs-lookup"><span data-stu-id="67b26-481">Otherwise, `TX` is the most encompassing type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="67b26-482">Pokud se přesně jeden typ, který sestává, nedá najít, převod je nejednoznačný a dojde k chybě při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="67b26-482">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="67b26-483">Najít nejvíce konkrétního operátora převodu:</span><span class="sxs-lookup"><span data-stu-id="67b26-483">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="67b26-484">Pokud `U` obsahuje právě jeden uživatelsky definovaný operátor převodu, který se převede z `SX` na `TX`, pak toto je nejpřesnější operátor převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-484">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="67b26-485">V opačném případě, pokud `U` obsahuje právě jeden převedený operátor převodu, který se převede z `SX` na `TX`, pak toto je nejpřesnější operátor převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-485">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="67b26-486">V opačném případě převod je nejednoznačný a dojde k chybě při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="67b26-486">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="67b26-487">Nakonec použít převod:</span><span class="sxs-lookup"><span data-stu-id="67b26-487">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="67b26-488">Pokud `S` není `SX`, je proveden standardní implicitní převod z `S` na `SX`.</span><span class="sxs-lookup"><span data-stu-id="67b26-488">If `S` is not `SX`, then a standard implicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="67b26-489">Nejpřesnější operátor převodu je vyvolán pro převod z `SX` na `TX`.</span><span class="sxs-lookup"><span data-stu-id="67b26-489">The most specific conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="67b26-490">Pokud `TX` není `T`, je proveden standardní implicitní převod z `TX` na `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-490">If `TX` is not `T`, then a standard implicit conversion from `TX` to `T` is performed.</span></span>

### <a name="processing-of-user-defined-explicit-conversions"></a><span data-ttu-id="67b26-491">Zpracování explicitních převodů definovaných uživatelem</span><span class="sxs-lookup"><span data-stu-id="67b26-491">Processing of user-defined explicit conversions</span></span>

<span data-ttu-id="67b26-492">Uživatelem definovaný explicitní převod z typu `S` na typ `T` je zpracován následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="67b26-492">A user-defined explicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="67b26-493">Určete typy `S0` a `T0`.</span><span class="sxs-lookup"><span data-stu-id="67b26-493">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="67b26-494">Pokud `S` nebo `T` jsou typy s možnou hodnotou null, `S0` a `T0` jsou jejich podkladové typy, jinak `S0` a `T0` jsou rovny `S` a `T` v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="67b26-494">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="67b26-495">Najde sadu typů `D`, ze kterých se budou brát v úvahu uživatelsky definované operátory převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-495">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="67b26-496">Tato sada se skládá z `S0` (Pokud `S0` je třída nebo struktura), základní třídy `S0` (Pokud `S0` je třída), `T0` (Pokud `T0` je třída nebo struktura) a základní třídy `T0` (Pokud `T0` je třída).</span><span class="sxs-lookup"><span data-stu-id="67b26-496">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), `T0` (if `T0` is a class or struct), and the base classes of `T0` (if `T0` is a class).</span></span>
*  <span data-ttu-id="67b26-497">Najděte sadu příslušných uživatelsky definovaných a přenesených operátorů převodu `U`.</span><span class="sxs-lookup"><span data-stu-id="67b26-497">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="67b26-498">Tato sada se skládá z uživatelem definovaných a převedených implicitních nebo explicitních operátorů převodu deklarovaných třídami nebo strukturami v `D`, které převádějí z typu zahrnujícího nebo zahrnutého `S` na typ, který zahrnuje nebo zahrnuje `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-498">This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing or encompassed by `S` to a type encompassing or encompassed by `T`.</span></span> <span data-ttu-id="67b26-499">Pokud je `U` prázdné, převod není definován a dojde k chybě při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="67b26-499">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="67b26-500">Vyhledá nejvíce konkrétní typ zdroje `SX`operátory v `U`:</span><span class="sxs-lookup"><span data-stu-id="67b26-500">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="67b26-501">Pokud některý z operátorů v `U` převést z `S`, `SX` `S`.</span><span class="sxs-lookup"><span data-stu-id="67b26-501">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="67b26-502">V opačném případě, pokud některý z operátorů v `U` převést z typů, které zahrnují `S`, pak `SX` je nejčastěji zahrnující typ v kombinované sadě zdrojových typů těchto operátorů.</span><span class="sxs-lookup"><span data-stu-id="67b26-502">Otherwise, if any of the operators in `U` convert from types that encompass `S`, then `SX` is the most encompassed type in the combined set of source types of those operators.</span></span> <span data-ttu-id="67b26-503">Pokud se nenajde žádný z výše zahrnutého typu, převod je nejednoznačný a dojde k chybě při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="67b26-503">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="67b26-504">V opačném případě je `SX` nejběžnějším typem v kombinované sadě zdrojových typů operátorů v `U`.</span><span class="sxs-lookup"><span data-stu-id="67b26-504">Otherwise, `SX` is the most encompassing type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="67b26-505">Pokud se přesně jeden typ, který sestává, nedá najít, převod je nejednoznačný a dojde k chybě při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="67b26-505">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="67b26-506">Vyhledá nejvíce konkrétní cílový typ `TX`operátory v `U`:</span><span class="sxs-lookup"><span data-stu-id="67b26-506">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="67b26-507">Pokud některý z operátorů v `U` převést na `T`, `TX` `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-507">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="67b26-508">V opačném případě, pokud některý z operátorů v `U` převést na typy, které jsou zahrnuté v `T`, pak `TX` je nejčastěji zahrnující typ v kombinované sadě cílových typů těchto operátorů.</span><span class="sxs-lookup"><span data-stu-id="67b26-508">Otherwise, if any of the operators in `U` convert to types that are encompassed by `T`, then `TX` is the most encompassing type in the combined set of target types of those operators.</span></span> <span data-ttu-id="67b26-509">Pokud se přesně jeden typ, který sestává, nedá najít, převod je nejednoznačný a dojde k chybě při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="67b26-509">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="67b26-510">V opačném případě `TX` je nejčastěji zahrnující typ v kombinované sadě cílových typů operátorů v `U`.</span><span class="sxs-lookup"><span data-stu-id="67b26-510">Otherwise, `TX` is the most encompassed type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="67b26-511">Pokud se nenajde žádný z výše zahrnutého typu, převod je nejednoznačný a dojde k chybě při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="67b26-511">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="67b26-512">Najít nejvíce konkrétního operátora převodu:</span><span class="sxs-lookup"><span data-stu-id="67b26-512">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="67b26-513">Pokud `U` obsahuje právě jeden uživatelsky definovaný operátor převodu, který se převede z `SX` na `TX`, pak toto je nejpřesnější operátor převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-513">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="67b26-514">V opačném případě, pokud `U` obsahuje právě jeden převedený operátor převodu, který se převede z `SX` na `TX`, pak toto je nejpřesnější operátor převodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-514">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="67b26-515">V opačném případě převod je nejednoznačný a dojde k chybě při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="67b26-515">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="67b26-516">Nakonec použít převod:</span><span class="sxs-lookup"><span data-stu-id="67b26-516">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="67b26-517">Pokud `S` není `SX`, provede se standardní explicitní převod z `S` na `SX`.</span><span class="sxs-lookup"><span data-stu-id="67b26-517">If `S` is not `SX`, then a standard explicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="67b26-518">Nejpřesnější uživatelsky definovaný operátor převodu je vyvolán pro převod z `SX` na `TX`.</span><span class="sxs-lookup"><span data-stu-id="67b26-518">The most specific user-defined conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="67b26-519">Pokud `TX` není `T`, provede se standardní explicitní převod z `TX` na `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-519">If `TX` is not `T`, then a standard explicit conversion from `TX` to `T` is performed.</span></span>

## <a name="anonymous-function-conversions"></a><span data-ttu-id="67b26-520">Anonymní převody funkcí</span><span class="sxs-lookup"><span data-stu-id="67b26-520">Anonymous function conversions</span></span>

<span data-ttu-id="67b26-521">*Anonymous_method_expression* nebo *lambda_expression* jsou klasifikovány jako anonymní funkce ([výrazy anonymní funkce](expressions.md#anonymous-function-expressions)).</span><span class="sxs-lookup"><span data-stu-id="67b26-521">An *anonymous_method_expression* or *lambda_expression* is classified as an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)).</span></span> <span data-ttu-id="67b26-522">Výraz nemá typ, ale lze jej implicitně převést na kompatibilní typ delegáta nebo strom výrazu.</span><span class="sxs-lookup"><span data-stu-id="67b26-522">The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type.</span></span> <span data-ttu-id="67b26-523">Konkrétně anonymní funkce `F` je kompatibilní s typem delegáta `D` poskytnutá:</span><span class="sxs-lookup"><span data-stu-id="67b26-523">Specifically, an anonymous function `F` is compatible with a delegate type `D` provided:</span></span>

*  <span data-ttu-id="67b26-524">Pokud `F` obsahuje *anonymous_function_signature*, `D` a `F` mají stejný počet parametrů.</span><span class="sxs-lookup"><span data-stu-id="67b26-524">If `F` contains an *anonymous_function_signature*, then `D` and `F` have the same number of parameters.</span></span>
*  <span data-ttu-id="67b26-525">Pokud `F` neobsahuje *anonymous_function_signature*, pak `D` může mít nula nebo více parametrů jakéhokoliv typu, pokud žádný parametr `D` nemá modifikátor `out` parametru.</span><span class="sxs-lookup"><span data-stu-id="67b26-525">If `F` does not contain an *anonymous_function_signature*, then `D` may have zero or more parameters of any type, as long as no parameter of `D` has the `out` parameter modifier.</span></span>
*  <span data-ttu-id="67b26-526">Pokud `F` má explicitně typový seznam parametrů, každý parametr v `D` má stejný typ a modifikátory jako odpovídající parametr v `F`.</span><span class="sxs-lookup"><span data-stu-id="67b26-526">If `F` has an explicitly typed parameter list, each parameter in `D` has the same type and modifiers as the corresponding parameter in `F`.</span></span>
*  <span data-ttu-id="67b26-527">Pokud `F` má implicitně typový seznam parametrů, `D` nemá žádné `ref` ani parametry `out`.</span><span class="sxs-lookup"><span data-stu-id="67b26-527">If `F` has an implicitly typed parameter list, `D` has no `ref` or `out` parameters.</span></span>
*  <span data-ttu-id="67b26-528">Pokud je tělo `F` výrazem a buď má `D` `void` návratový typ, nebo je `F` asynchronní a `D` návratového typu, pak když je každý parametr `Task`přiřazen typu odpovídajícího parametru v `F`, tělo `D`je platným výrazem (WRT [výrazy](expressions.md)), který by byl povolen jako *`F`* ([příkazy výrazu](statements.md#expression-statements)).</span><span class="sxs-lookup"><span data-stu-id="67b26-528">If the body of `F` is an expression, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that would be permitted as a *statement_expression* ([Expression statements](statements.md#expression-statements)).</span></span>
*  <span data-ttu-id="67b26-529">Pokud je tělo `F` blok příkazu a buď má `D` `void` návratový typ, nebo je `F` asynchronní a `D` návratového typu, pak když je každý parametr `Task`přiřazen typu odpovídajícího parametru v `F`, tělo `D`je platným blokem příkazu ( [bloky](statements.md#blocks)WRT), ve kterém žádný příkaz `F` neurčuje výraz.</span><span class="sxs-lookup"><span data-stu-id="67b26-529">If the body of `F` is a statement block, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) in which no `return` statement specifies an expression.</span></span>
*  <span data-ttu-id="67b26-530">Pokud je text `F` výraz a *buď* `F` je neasynchronní a `D` je návratový `T`typ jiný než void, *nebo* `F` je Async a `D` má návratový typ `Task<T>`, pak když je každý parametr `F` dán typem odpovídajícího parametru v `D`, tělo `F` je platný výraz (WRT [výrazy](expressions.md)), který je implicitně převeden na `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-530">If the body of `F` is an expression, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that is implicitly convertible to `T`.</span></span>
*  <span data-ttu-id="67b26-531">Pokud je text `F` blok příkazu a *buď* `F` je neasynchronní a `D` má návratový typ, který není void `T`, *nebo* `F` je Async a `D` má návratový typ `Task<T>`, pak když každý parametr `F` má přidělen typ odpovídajícího parametru v `D`, tělo `F` je platným blokem příkazu ( [bloky](statements.md#blocks)WRT) s nedosažitelným koncovým bodem, ve kterém každý příkaz `return` určuje výraz, který je implicitně převeden na `T`.</span><span class="sxs-lookup"><span data-stu-id="67b26-531">If the body of `F` is a statement block, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) with a non-reachable end point in which each `return` statement specifies an expression that is implicitly convertible to `T`.</span></span>

<span data-ttu-id="67b26-532">Pro účely zkrácení Tato část používá krátký tvar typů úloh `Task` a `Task<T>` ([asynchronní funkce](classes.md#async-functions)).</span><span class="sxs-lookup"><span data-stu-id="67b26-532">For the purpose of brevity, this section uses the short form for the task types `Task` and `Task<T>` ([Async functions](classes.md#async-functions)).</span></span>

<span data-ttu-id="67b26-533">Výraz lambda `F` je kompatibilní s typem stromu výrazu `Expression<D>`, pokud `F` je kompatibilní s typem delegáta `D`.</span><span class="sxs-lookup"><span data-stu-id="67b26-533">A lambda expression `F` is compatible with an expression tree type `Expression<D>` if `F` is compatible with the delegate type `D`.</span></span> <span data-ttu-id="67b26-534">Všimněte si, že to neplatí pro anonymní metody, pouze lambda výrazy.</span><span class="sxs-lookup"><span data-stu-id="67b26-534">Note that this does not apply to anonymous methods, only lambda expressions.</span></span>

<span data-ttu-id="67b26-535">Některé výrazy lambda nelze převést na typy stromu výrazů: i když převod *existuje*, při kompilaci dojde k chybě.</span><span class="sxs-lookup"><span data-stu-id="67b26-535">Certain lambda expressions cannot be converted to expression tree types: Even though the conversion *exists*, it fails at compile-time.</span></span> <span data-ttu-id="67b26-536">Toto je případ, pokud výraz lambda:</span><span class="sxs-lookup"><span data-stu-id="67b26-536">This is the case if the lambda expression:</span></span>

*  <span data-ttu-id="67b26-537">Má tělo *bloku*</span><span class="sxs-lookup"><span data-stu-id="67b26-537">Has a *block* body</span></span>
*  <span data-ttu-id="67b26-538">Obsahuje operátory jednoduchého nebo složeného přiřazení.</span><span class="sxs-lookup"><span data-stu-id="67b26-538">Contains simple or compound assignment operators</span></span>
*  <span data-ttu-id="67b26-539">Obsahuje dynamicky vázaný výraz</span><span class="sxs-lookup"><span data-stu-id="67b26-539">Contains a dynamically bound expression</span></span>
*  <span data-ttu-id="67b26-540">Je asynchronní</span><span class="sxs-lookup"><span data-stu-id="67b26-540">Is async</span></span>

<span data-ttu-id="67b26-541">Níže uvedené příklady používají typ obecného delegáta `Func<A,R>`, který představuje funkci, která přebírá argument typu `A` a vrací hodnotu typu `R`:</span><span class="sxs-lookup"><span data-stu-id="67b26-541">The examples that follow use a generic delegate type `Func<A,R>` which represents a function that takes an argument of type `A` and returns a value of type `R`:</span></span>
```csharp
delegate R Func<A,R>(A arg);
```

<span data-ttu-id="67b26-542">V přiřazeních</span><span class="sxs-lookup"><span data-stu-id="67b26-542">In the assignments</span></span>
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
<span data-ttu-id="67b26-543">parametry a návratové typy jednotlivých anonymních funkcí jsou určeny z typu proměnné, ke které je přiřazena anonymní funkce.</span><span class="sxs-lookup"><span data-stu-id="67b26-543">the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</span></span>

<span data-ttu-id="67b26-544">První přiřazení úspěšně převede anonymní funkci na typ delegáta `Func<int,int>`, protože pokud `x` předaný typ `int`, `x+1` je platný výraz, který lze implicitně převést na typ `int`.</span><span class="sxs-lookup"><span data-stu-id="67b26-544">The first assignment successfully converts the anonymous function to the delegate type `Func<int,int>` because, when `x` is given type `int`, `x+1` is a valid expression that is implicitly convertible to type `int`.</span></span>

<span data-ttu-id="67b26-545">Stejně tak druhé přiřazení úspěšně převede anonymní funkci na typ delegáta `Func<int,double>`, protože výsledek `x+1` (typu `int`) je implicitně převeden na typ `double`.</span><span class="sxs-lookup"><span data-stu-id="67b26-545">Likewise, the second assignment successfully converts the anonymous function to the delegate type `Func<int,double>` because the result of `x+1` (of type `int`) is implicitly convertible to type `double`.</span></span>

<span data-ttu-id="67b26-546">Třetí přiřazení je ale chyba při kompilaci, protože když `x` je předaný typ `double`, není výsledek `x+1` (typu `double`) implicitně převoditelný na typ `int`.</span><span class="sxs-lookup"><span data-stu-id="67b26-546">However, the third assignment is a compile-time error because, when `x` is given type `double`, the result of `x+1` (of type `double`) is not implicitly convertible to type `int`.</span></span>

<span data-ttu-id="67b26-547">Čtvrté přiřazení úspěšně převede anonymní asynchronní funkci na typ delegáta `Func<int, Task<int>>`, protože výsledek `x+1` (typu `int`) je implicitně převeden na typ výsledku `int` typu úlohy `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="67b26-547">The fourth assignment successfully converts the anonymous async function to the delegate type `Func<int, Task<int>>` because the result of `x+1` (of type `int`) is implicitly convertible to the result type `int` of the task type `Task<int>`.</span></span>

<span data-ttu-id="67b26-548">Anonymní funkce mohou ovlivnit rozlišení přetížení a účastnit se odvození typu.</span><span class="sxs-lookup"><span data-stu-id="67b26-548">Anonymous functions may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="67b26-549">Další podrobnosti viz [Členové funkce](expressions.md#function-members) .</span><span class="sxs-lookup"><span data-stu-id="67b26-549">See [Function members](expressions.md#function-members) for further details.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a><span data-ttu-id="67b26-550">Vyhodnocení anonymních převodů funkcí na typy delegátů</span><span class="sxs-lookup"><span data-stu-id="67b26-550">Evaluation of anonymous function conversions to delegate types</span></span>

<span data-ttu-id="67b26-551">Převod anonymní funkce na typ delegáta vytvoří instanci delegáta, která odkazuje na anonymní funkci a (případně prázdnou) sadu zachycených vnějších proměnných, které jsou aktivní v době vyhodnocení.</span><span class="sxs-lookup"><span data-stu-id="67b26-551">Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation.</span></span> <span data-ttu-id="67b26-552">Když je vyvolán delegát, je provedeno tělo anonymní funkce.</span><span class="sxs-lookup"><span data-stu-id="67b26-552">When the delegate is invoked, the body of the anonymous function is executed.</span></span> <span data-ttu-id="67b26-553">Kód v těle je proveden pomocí sady zachycených vnějších proměnných, na které odkazuje delegát.</span><span class="sxs-lookup"><span data-stu-id="67b26-553">The code in the body is executed using the set of captured outer variables referenced by the delegate.</span></span>

<span data-ttu-id="67b26-554">Seznam volání delegáta vytvořeného z anonymní funkce obsahuje jednu položku.</span><span class="sxs-lookup"><span data-stu-id="67b26-554">The invocation list of a delegate produced from an anonymous function contains a single entry.</span></span> <span data-ttu-id="67b26-555">Přesný cílový objekt a cílová metoda delegáta nejsou určeny.</span><span class="sxs-lookup"><span data-stu-id="67b26-555">The exact target object and target method of the delegate are unspecified.</span></span> <span data-ttu-id="67b26-556">Konkrétně není určeno, zda je cílový objekt delegáta `null`, `this` hodnota ohraničujícího člena funkce nebo jiný objekt.</span><span class="sxs-lookup"><span data-stu-id="67b26-556">In particular, it is unspecified whether the target object of the delegate is `null`, the `this` value of the enclosing function member, or some other object.</span></span>

<span data-ttu-id="67b26-557">Převody sémanticky identických anonymních funkcí se stejnou (možná prázdnou) sadou zachycených instancí vnějších proměnných na stejné typy delegátů jsou povoleny (ale nejsou požadovány) pro vrácení stejné instance delegáta.</span><span class="sxs-lookup"><span data-stu-id="67b26-557">Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance.</span></span> <span data-ttu-id="67b26-558">Pojem sémanticky totožné se zde používá, aby bylo možné, že provádění anonymních funkcí bude ve všech případech dávat stejné důsledky pro stejné argumenty.</span><span class="sxs-lookup"><span data-stu-id="67b26-558">The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments.</span></span> <span data-ttu-id="67b26-559">Toto pravidlo povoluje optimalizaci kódu, jako je například následující.</span><span class="sxs-lookup"><span data-stu-id="67b26-559">This rule permits code such as the following to be optimized.</span></span>

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

<span data-ttu-id="67b26-560">Vzhledem k tomu, že dva Delegáti anonymních funkcí mají stejnou (prázdnou) sadu zachycených vnějších proměnných a vzhledem k tomu, že anonymní funkce jsou sémanticky identické, kompilátor má oprávnění odkazovat na stejnou cílovou metodu.</span><span class="sxs-lookup"><span data-stu-id="67b26-560">Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method.</span></span> <span data-ttu-id="67b26-561">Kompilátor je však povolen pro vrácení stejné instance delegáta z anonymních výrazů Functions.</span><span class="sxs-lookup"><span data-stu-id="67b26-561">Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a><span data-ttu-id="67b26-562">Vyhodnocení anonymních převodů funkcí na typy stromu výrazů</span><span class="sxs-lookup"><span data-stu-id="67b26-562">Evaluation of anonymous function conversions to expression tree types</span></span>

<span data-ttu-id="67b26-563">Převod anonymní funkce na typ stromu výrazu vytvoří strom výrazu ([typy stromu výrazů](types.md#expression-tree-types)).</span><span class="sxs-lookup"><span data-stu-id="67b26-563">Conversion of an anonymous function to an expression tree type produces an expression tree ([Expression tree types](types.md#expression-tree-types)).</span></span> <span data-ttu-id="67b26-564">Přesněji, vyhodnocení konverze anonymní funkce vede k konstrukci struktury objektů, která představuje strukturu samotné anonymní funkce.</span><span class="sxs-lookup"><span data-stu-id="67b26-564">More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself.</span></span> <span data-ttu-id="67b26-565">Přesná struktura stromu výrazu a také přesný proces pro jeho vytvoření jsou definovány implementací.</span><span class="sxs-lookup"><span data-stu-id="67b26-565">The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</span></span>

### <a name="implementation-example"></a><span data-ttu-id="67b26-566">Příklad implementace</span><span class="sxs-lookup"><span data-stu-id="67b26-566">Implementation example</span></span>

<span data-ttu-id="67b26-567">Tato část popisuje možnou implementaci anonymních převodů funkcí v souvislosti s C# jinými konstrukcemi.</span><span class="sxs-lookup"><span data-stu-id="67b26-567">This section describes a possible implementation of anonymous function conversions in terms of other C# constructs.</span></span> <span data-ttu-id="67b26-568">Zde popsaná implementace je založena na stejných zásadách, které používá kompilátor společnosti C# Microsoft, ale nejedná se o udělenou implementaci, ani o to, že to není jediné.</span><span class="sxs-lookup"><span data-stu-id="67b26-568">The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible.</span></span> <span data-ttu-id="67b26-569">Krátce se zmiňuje o převodech na stromy výrazů, protože jejich Přesná sémantika je mimo rozsah této specifikace.</span><span class="sxs-lookup"><span data-stu-id="67b26-569">It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</span></span>

<span data-ttu-id="67b26-570">Zbývající část tohoto oddílu obsahuje několik příkladů kódu, které obsahují anonymní funkce s různými charakteristikami.</span><span class="sxs-lookup"><span data-stu-id="67b26-570">The remainder of this section gives several examples of code that contains anonymous functions with different characteristics.</span></span> <span data-ttu-id="67b26-571">Pro každý příklad je k dispozici odpovídající překlad kódu, který používá C# pouze jiné konstrukce.</span><span class="sxs-lookup"><span data-stu-id="67b26-571">For each example, a corresponding translation to code that uses only other C# constructs is provided.</span></span> <span data-ttu-id="67b26-572">V příkladech se k identifikátoru `D` předpokládá, že představuje následující typ delegáta:</span><span class="sxs-lookup"><span data-stu-id="67b26-572">In the examples, the identifier `D` is assumed by represent the following delegate type:</span></span>
```csharp
public delegate void D();
```

<span data-ttu-id="67b26-573">Nejjednodušší forma anonymní funkce je taková, která zachytává žádné vnější proměnné:</span><span class="sxs-lookup"><span data-stu-id="67b26-573">The simplest form of an anonymous function is one that captures no outer variables:</span></span>
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

<span data-ttu-id="67b26-574">To lze přeložit na instanci delegáta, která odkazuje na statickou metodu generovanou kompilátorem, ve které je umístěn kód anonymní funkce:</span><span class="sxs-lookup"><span data-stu-id="67b26-574">This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:</span></span>
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

<span data-ttu-id="67b26-575">V následujícím příkladu anonymní funkce odkazuje na členy instance `this`:</span><span class="sxs-lookup"><span data-stu-id="67b26-575">In the following example, the anonymous function references instance members of `this`:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

<span data-ttu-id="67b26-576">To lze přeložit na metodu instance generovanou kompilátorem, která obsahuje kód anonymní funkce:</span><span class="sxs-lookup"><span data-stu-id="67b26-576">This can be translated to a compiler generated instance method containing the code of the anonymous function:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

<span data-ttu-id="67b26-577">V tomto příkladu anonymní funkce zachytí místní proměnnou:</span><span class="sxs-lookup"><span data-stu-id="67b26-577">In this example, the anonymous function captures a local variable:</span></span>
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

<span data-ttu-id="67b26-578">Životnost místní proměnné se teď musí rozšířit aspoň na dobu života delegáta anonymní funkce.</span><span class="sxs-lookup"><span data-stu-id="67b26-578">The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate.</span></span> <span data-ttu-id="67b26-579">To lze dosáhnout použitím "zdvihacího" místní proměnné do pole třídy generované kompilátorem.</span><span class="sxs-lookup"><span data-stu-id="67b26-579">This can be achieved by "hoisting" the local variable into a field of a compiler generated class.</span></span> <span data-ttu-id="67b26-580">Vytvoření instance místní proměnné ([vytváření instancí místních proměnných](expressions.md#instantiation-of-local-variables)) pak odpovídá vytvoření instance třídy generované kompilátorem a přístup k místní proměnné odpovídá přístupu k poli v instanci třídy generované kompilátorem.</span><span class="sxs-lookup"><span data-stu-id="67b26-580">Instantiation of the local variable ([Instantiation of local variables](expressions.md#instantiation-of-local-variables)) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class.</span></span> <span data-ttu-id="67b26-581">Anonymní funkce se navíc stávají metodou instance třídy generované kompilátorem:</span><span class="sxs-lookup"><span data-stu-id="67b26-581">Furthermore, the anonymous function becomes an instance method of the compiler generated class:</span></span>
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

<span data-ttu-id="67b26-582">Nakonec následující anonymní funkce zachytí `this` a také dvě místní proměnné s různými životnostmi:</span><span class="sxs-lookup"><span data-stu-id="67b26-582">Finally, the following anonymous function captures `this` as well as two local variables with different lifetimes:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

<span data-ttu-id="67b26-583">Tady je vytvořena třída vygenerovaná kompilátorem pro každý blok příkazu, ve kterém jsou lokální hodnoty zachyceny tak, že místní proměnné v různých blocích mohou mít nezávislé životnosti.</span><span class="sxs-lookup"><span data-stu-id="67b26-583">Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes.</span></span> <span data-ttu-id="67b26-584">Instance `__Locals2`, třída vygenerovaná kompilátorem pro blok vnitřního příkazu, obsahuje místní proměnnou `z` a pole, které odkazuje na instanci `__Locals1`.</span><span class="sxs-lookup"><span data-stu-id="67b26-584">An instance of `__Locals2`, the compiler generated class for the inner statement block, contains the local variable `z` and a field that references an instance of `__Locals1`.</span></span>  <span data-ttu-id="67b26-585">Instance `__Locals1`, třída vygenerovaná kompilátorem pro blok vnějšího příkazu, obsahuje místní proměnnou `y` a pole, které odkazuje `this` ohraničujícího člena funkce.</span><span class="sxs-lookup"><span data-stu-id="67b26-585">An instance of `__Locals1`, the compiler generated class for the outer statement block, contains the local variable `y` and a field that references `this` of the enclosing function member.</span></span> <span data-ttu-id="67b26-586">Pomocí těchto datových struktur je možné dosáhnout všech zachycených vnějších proměnných prostřednictvím instance `__Local2`a kód anonymní funkce lze proto implementovat jako metodu instance této třídy.</span><span class="sxs-lookup"><span data-stu-id="67b26-586">With these data structures it is possible to reach all captured outer variables through an instance of `__Local2`, and the code of the anonymous function can thus be implemented as an instance method of that class.</span></span>

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

<span data-ttu-id="67b26-587">Stejný postup, který se používá pro zachycení místních proměnných, se dá použít i při převodu anonymních funkcí na stromy výrazů: odkazy na objekty vygenerované kompilátorem můžou být uložené ve stromu výrazů a přístup k místním proměnným může být. je reprezentovaná jako přístup k poli u těchto objektů.</span><span class="sxs-lookup"><span data-stu-id="67b26-587">The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects.</span></span> <span data-ttu-id="67b26-588">Výhodou tohoto přístupu je to, že umožňuje sdílení "" vyzdvižených "místních proměnných mezi delegáty a stromy výrazů.</span><span class="sxs-lookup"><span data-stu-id="67b26-588">The advantage of this approach is that it allows the "lifted" local variables to be shared between delegates and expression trees.</span></span>

## <a name="method-group-conversions"></a><span data-ttu-id="67b26-589">Převody skupin metod</span><span class="sxs-lookup"><span data-stu-id="67b26-589">Method group conversions</span></span>

<span data-ttu-id="67b26-590">Implicitní převod ([implicitní převody](conversions.md#implicit-conversions)) existuje ze skupiny metod ([klasifikace výrazů](expressions.md#expression-classifications)) na kompatibilní typ delegáta.</span><span class="sxs-lookup"><span data-stu-id="67b26-590">An implicit conversion ([Implicit conversions](conversions.md#implicit-conversions)) exists from a method group ([Expression classifications](expressions.md#expression-classifications)) to a compatible delegate type.</span></span> <span data-ttu-id="67b26-591">Vzhledem k typu delegáta `D` a výrazu `E`, který je klasifikován jako skupina metod, existuje implicitní převod z `E` na `D`, pokud `E` obsahuje alespoň jednu metodu, která je použita v normálním formuláři ([příslušný člen funkce](expressions.md#applicable-function-member)) na seznam argumentů konstruovaných pomocí typů parametrů a modifikátorů `D`, jak je popsáno v následujícím tématu.</span><span class="sxs-lookup"><span data-stu-id="67b26-591">Given a delegate type `D` and an expression `E` that is classified as a method group, an implicit conversion exists from `E` to `D` if `E` contains at least one method that is applicable in its normal form ([Applicable function member](expressions.md#applicable-function-member)) to an argument list constructed by use of the parameter types and modifiers of `D`, as described in the following.</span></span>

<span data-ttu-id="67b26-592">Aplikace v době kompilace převodu ze skupiny metod `E` na typ delegáta `D` je popsána v následujícím tématu.</span><span class="sxs-lookup"><span data-stu-id="67b26-592">The compile-time application of a conversion from a method group `E` to a delegate type `D` is described in the following.</span></span> <span data-ttu-id="67b26-593">Počítejte s tím, že existence implicitního převodu z `E` na `D` nezaručuje, že při kompilaci dojde k úspěšnému provedení převodu bez chyby.</span><span class="sxs-lookup"><span data-stu-id="67b26-593">Note that the existence of an implicit conversion from `E` to `D` does not guarantee that the compile-time application of the conversion will succeed without error.</span></span>

*  <span data-ttu-id="67b26-594">Je vybrána jedna metoda `M` odpovídající vyvolání metody ([vyvolání metod](expressions.md#method-invocations)) `E(A)`formuláře s následujícími změnami:</span><span class="sxs-lookup"><span data-stu-id="67b26-594">A single method `M` is selected corresponding to a method invocation ([Method invocations](expressions.md#method-invocations)) of the form `E(A)`, with the following modifications:</span></span>
    * <span data-ttu-id="67b26-595">Seznam argumentů `A` je seznam výrazů, každý klasifikovaný jako proměnná a s typem a modifikátorem (`ref` nebo `out`) odpovídajícího parametru v *formal_parameter_list* `D`.</span><span class="sxs-lookup"><span data-stu-id="67b26-595">The argument list `A` is a list of expressions, each classified as a variable and with the type and modifier (`ref` or `out`) of the corresponding parameter in the *formal_parameter_list* of `D`.</span></span>
    * <span data-ttu-id="67b26-596">Uvažované metody kandidáta jsou pouze metody, které jsou použitelné v jejich normálním formátu ([platný člen funkce](expressions.md#applicable-function-member)), nikoli ty, které platí pouze v rozbalených formulářích.</span><span class="sxs-lookup"><span data-stu-id="67b26-596">The candidate methods considered are only those methods that are applicable in their normal form ([Applicable function member](expressions.md#applicable-function-member)), not those applicable only in their expanded form.</span></span>
*  <span data-ttu-id="67b26-597">Pokud algoritmus [vyvolání metody](expressions.md#method-invocations) vyvolá chybu, dojde k chybě při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="67b26-597">If the algorithm of [Method invocations](expressions.md#method-invocations) produces an error, then a compile-time error occurs.</span></span> <span data-ttu-id="67b26-598">V opačném případě algoritmus vytvoří jednu nejlepší metodu `M` se stejným počtem parametrů jako `D` a převod je považován za existující.</span><span class="sxs-lookup"><span data-stu-id="67b26-598">Otherwise the algorithm produces a single best method `M` having the same number of parameters as `D` and the conversion is considered to exist.</span></span>
*  <span data-ttu-id="67b26-599">Vybraná metoda `M` musí být kompatibilní s typem[delegáta](delegates.md#delegate-compatibility)`D`nebo v opačném případě dojde k chybě při kompilaci.</span><span class="sxs-lookup"><span data-stu-id="67b26-599">The selected method `M` must be compatible ([Delegate compatibility](delegates.md#delegate-compatibility)) with the delegate type `D`, or otherwise, a compile-time error occurs.</span></span>
*  <span data-ttu-id="67b26-600">Pokud je vybraná metoda `M` metoda instance, výraz instance přidružený k `E` Určuje cílový objekt delegáta.</span><span class="sxs-lookup"><span data-stu-id="67b26-600">If the selected method `M` is an instance method, the instance expression associated with `E` determines the target object of the delegate.</span></span>
*  <span data-ttu-id="67b26-601">Pokud je vybraná metoda M rozšíření rozšiřující metoda, která je označena pomocí přístupu člena k výrazu instance, tento výraz instance Určuje cílový objekt delegáta.</span><span class="sxs-lookup"><span data-stu-id="67b26-601">If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</span></span>
*  <span data-ttu-id="67b26-602">Výsledkem převodu je hodnota typu `D`, konkrétně nově vytvořený delegát, který odkazuje na vybranou metodu a cílový objekt.</span><span class="sxs-lookup"><span data-stu-id="67b26-602">The result of the conversion is a value of type `D`, namely a newly created delegate that refers to the selected method and target object.</span></span>
*  <span data-ttu-id="67b26-603">Všimněte si, že tento proces může vést k vytvoření delegáta metody rozšíření, pokud algoritmus [vyvolání metody](expressions.md#method-invocations) nenalezne metodu instance, ale úspěch zpracovává vyvolání `E(A)` jako volání metody rozšíření ([vyvolání rozšiřující metody](expressions.md#extension-method-invocations)).</span><span class="sxs-lookup"><span data-stu-id="67b26-603">Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of [Method invocations](expressions.md#method-invocations) fails to find an instance method but succeeds in processing the invocation of `E(A)` as an extension method invocation ([Extension method invocations](expressions.md#extension-method-invocations)).</span></span> <span data-ttu-id="67b26-604">Takto vytvořený delegát zachytí metodu rozšíření i její první argument.</span><span class="sxs-lookup"><span data-stu-id="67b26-604">A delegate thus created captures the extension method as well as its first argument.</span></span>

<span data-ttu-id="67b26-605">Následující příklad ukazuje převody skupin metod:</span><span class="sxs-lookup"><span data-stu-id="67b26-605">The following example demonstrates method group conversions:</span></span>
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

<span data-ttu-id="67b26-606">Přiřazení `d1` implicitně převede skupinu metod `F` na hodnotu typu `D1`.</span><span class="sxs-lookup"><span data-stu-id="67b26-606">The assignment to `d1` implicitly converts the method group `F` to a value of type `D1`.</span></span>

<span data-ttu-id="67b26-607">Přiřazení `d2` ukazuje, jak je možné vytvořit delegáta pro metodu, která má méně odvozené (kontravariantní) typy parametrů a další odvozené (kovariantní) návratový typ.</span><span class="sxs-lookup"><span data-stu-id="67b26-607">The assignment to `d2` shows how it is possible to create a delegate to a method that has less derived (contravariant) parameter types and a more derived (covariant) return type.</span></span>

<span data-ttu-id="67b26-608">Přiřazení `d3` ukazuje, jak žádný převod neexistuje, pokud metoda není k dispozici.</span><span class="sxs-lookup"><span data-stu-id="67b26-608">The assignment to `d3` shows how no conversion exists if the method is not applicable.</span></span>

<span data-ttu-id="67b26-609">Přiřazení `d4` ukazuje, jak se metoda musí použít v normálním tvaru.</span><span class="sxs-lookup"><span data-stu-id="67b26-609">The assignment to `d4` shows how the method must be applicable in its normal form.</span></span>

<span data-ttu-id="67b26-610">Přiřazení `d5` ukazuje, jak se mohou parametry a návratové typy delegáta a metody lišit pouze pro typy odkazů.</span><span class="sxs-lookup"><span data-stu-id="67b26-610">The assignment to `d5` shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</span></span>

<span data-ttu-id="67b26-611">Stejně jako u všech ostatních implicitních a explicitních převodů lze operátor přetypování použít k explicitnímu provedení převodu skupiny metody.</span><span class="sxs-lookup"><span data-stu-id="67b26-611">As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion.</span></span> <span data-ttu-id="67b26-612">Proto příklad</span><span class="sxs-lookup"><span data-stu-id="67b26-612">Thus, the example</span></span>
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
<span data-ttu-id="67b26-613">místo toho je možné zapisovat.</span><span class="sxs-lookup"><span data-stu-id="67b26-613">could instead be written</span></span>
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

<span data-ttu-id="67b26-614">Skupiny metod mohou ovlivnit rozlišení přetížení a účastnit se odvození typu.</span><span class="sxs-lookup"><span data-stu-id="67b26-614">Method groups may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="67b26-615">Další podrobnosti viz [Členové funkce](expressions.md#function-members) .</span><span class="sxs-lookup"><span data-stu-id="67b26-615">See [Function members](expressions.md#function-members) for further details.</span></span>

<span data-ttu-id="67b26-616">Vyhodnocení převodu skupiny metod metodou Run-Time pokračuje následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="67b26-616">The run-time evaluation of a method group conversion proceeds as follows:</span></span>

*  <span data-ttu-id="67b26-617">Pokud je metoda vybraná v době kompilace metoda instance, nebo se jedná o metodu rozšíření, která je k dispozici jako metoda instance, je cílový objekt delegáta určen z výrazu instance přidruženého k `E`:</span><span class="sxs-lookup"><span data-stu-id="67b26-617">If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with `E`:</span></span>
    * <span data-ttu-id="67b26-618">Výraz instance je vyhodnocen.</span><span class="sxs-lookup"><span data-stu-id="67b26-618">The instance expression is evaluated.</span></span> <span data-ttu-id="67b26-619">Pokud toto vyhodnocení způsobí výjimku, nejsou provedeny žádné další kroky.</span><span class="sxs-lookup"><span data-stu-id="67b26-619">If this evaluation causes an exception, no further steps are executed.</span></span>
    * <span data-ttu-id="67b26-620">Pokud je výraz instance *reference_type*, hodnota počítaná výrazem instance se stala cílovým objektem.</span><span class="sxs-lookup"><span data-stu-id="67b26-620">If the instance expression is of a *reference_type*, the value computed by the instance expression becomes the target object.</span></span> <span data-ttu-id="67b26-621">Pokud je vybraná metoda metoda instance a cílový objekt je `null`, je vyvolána `System.NullReferenceException` a nejsou provedeny žádné další kroky.</span><span class="sxs-lookup"><span data-stu-id="67b26-621">If the selected method is an instance method and the target object is `null`, a `System.NullReferenceException` is thrown and no further steps are executed.</span></span>
    * <span data-ttu-id="67b26-622">Pokud je výraz instance *value_type*, je provedena operace zabalení ([převody zabalení](types.md#boxing-conversions)) pro převod hodnoty na objekt a tento objekt se stává cílovým objektem.</span><span class="sxs-lookup"><span data-stu-id="67b26-622">If the instance expression is of a *value_type*, a boxing operation ([Boxing conversions](types.md#boxing-conversions)) is performed to convert the value to an object, and this object becomes the target object.</span></span>
*  <span data-ttu-id="67b26-623">V opačném případě je vybraná metoda součástí volání statické metody a cílový objekt delegáta je `null`.</span><span class="sxs-lookup"><span data-stu-id="67b26-623">Otherwise the selected method is part of a static method call, and the target object of the delegate is `null`.</span></span>
*  <span data-ttu-id="67b26-624">Je přidělena nová instance typu delegáta `D`.</span><span class="sxs-lookup"><span data-stu-id="67b26-624">A new instance of the delegate type `D` is allocated.</span></span> <span data-ttu-id="67b26-625">Pokud není k dispozici dostatek paměti pro přidělení nové instance, je vyvolána `System.OutOfMemoryException` a nejsou spuštěny žádné další kroky.</span><span class="sxs-lookup"><span data-stu-id="67b26-625">If there is not enough memory available to allocate the new instance, a `System.OutOfMemoryException` is thrown and no further steps are executed.</span></span>
*  <span data-ttu-id="67b26-626">Nová instance delegáta je inicializována s odkazem na metodu, která byla určena v době kompilace, a odkaz na cílový objekt vypočítaný výše.</span><span class="sxs-lookup"><span data-stu-id="67b26-626">The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</span></span>
